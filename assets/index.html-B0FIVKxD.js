import{a as s,c as a,d as i,o as n}from"./app-BAiM96bE.js";const t={};function r(o,e){return n(),a("div",null,[...e[0]||(e[0]=[i(`<blockquote><p>主要内容摘抄自 <a href="https://code.visualstudio.com/updates/v1_89" target="_blank" rel="noopener noreferrer">VSCode 1.89 发行说明</a>，文中“我们”即 VSCode</p></blockquote><h2 id="本地工作区扩展" tabindex="-1"><a class="header-anchor" href="#本地工作区扩展"><span><a href="https://code.visualstudio.com/updates/v1_89#_local-workspace-extensions" target="_blank" rel="noopener noreferrer">本地工作区扩展</a></span></a></h2><p>本地工作区扩展首次在 VS Code 1.88 版本中推出，现已（v1.89）普遍可用。您现在可以直接将扩展包含在您的工作区中，并仅为该工作区安装它。此功能旨在满足您特定的工作区需求，并提供更加量身定制的开发体验。</p><p>要使用此功能，您需要将扩展放在您的工作区的.vscode/extensions 文件夹中。然后，VS Code 会在扩展视图的工作区推荐部分显示此扩展，用户可以从那里安装它。VS Code 仅为该工作区安装此扩展。本地工作区扩展需要用户信任工作区，然后才能安装和运行此扩展。</p><p>请注意，您应该将解压后的扩展包含在.vscode/extensions 文件夹中，而不是 VSIX 文件。您也可以只包含扩展的源代码，并将其作为工作区设置的一部分构建。</p><p>这真是令人兴奋的更新，<a href="https://ld246.com/forward?goto=https%3A%2F%2Fgithub.com%2FHi-Windom%2FSillot%2Fissues%2F681" target="_blank" rel="noopener noreferrer">汐洛插件现已适配该特性</a></p><h2 id="快速打开中的自定义编辑器标签" tabindex="-1"><a class="header-anchor" href="#快速打开中的自定义编辑器标签"><span><a href="https://code.visualstudio.com/updates/v1_89#_custom-editor-labels-in-quick-open" target="_blank" rel="noopener noreferrer">快速打开中的自定义编辑器标签</a></span></a></h2><p>上个月，我们推出了<a href="https://ld246.com/forward?goto=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fgetstarted%2Fuserinterface%23_customize-tab-labels" target="_blank" rel="noopener noreferrer">自定义标签功能</a>，让您可以个性化编辑器标签。该功能旨在帮助您更轻松地区分具有相同名称的文件的标签，例如 index.tsx 文件。</p><p>在此基础上，我们已将自定义标签的使用扩展到快速打开功能 (Ctrl+P)。现在，您可以使用您创建的自定义标签搜索文件，使文件导航更加直观。</p><p>这个更新在我看来有点乏善可陈，毕竟更新前也可以轻易区分同名的标签，不过汐洛还是记录在案了。</p><h2 id="切换分支时保存-恢复打开的编辑器" tabindex="-1"><a class="header-anchor" href="#切换分支时保存-恢复打开的编辑器"><span><a href="https://code.visualstudio.com/updates/v1_89#_saverestore-open-editors-when-switching-branches" target="_blank" rel="noopener noreferrer">切换分支时保存/恢复打开的编辑器</a></span></a></h2><p>这个里程碑，我们解决了一个长期存在的功能请求，即在源代码控制分支之间切换时保存和恢复编辑器。 使用 <code>&quot;scm.workingSets.enabled&quot;: true</code> 设置以启用此功能。</p><p>当首次切换到一个分支时，要控制打开的编辑器，可以使用 scm.workingSets.default 设置。您可以选择没有打开的编辑器（空），或者使用当前已打开的编辑器（current， 默认值）。</p><h2 id="禁用大型笔记本的备份" tabindex="-1"><a class="header-anchor" href="#禁用大型笔记本的备份"><span><a href="https://code.visualstudio.com/updates/v1_89#_disabled-backups-for-large-notebooks" target="_blank" rel="noopener noreferrer">禁用大型笔记本的备份</a></span></a></h2><p>现在已经禁用了大型笔记本文件的周期性文件备份，以减少写入磁盘的时间。可以通过设置 <code>notebook.backup.sizeLimit</code> 来调整限制。我们还在尝试一个选项 <code>&quot;notebook.experimental.remoteSave&quot;: true</code> ，可以在保存笔记本文件时避免阻塞渲染器，以便自动保存不会带来性能损失。</p><h2 id="修复大纲-粘性滚动性能退化问题" tabindex="-1"><a class="header-anchor" href="#修复大纲-粘性滚动性能退化问题"><span><a href="https://code.visualstudio.com/updates/v1_89#_fix-for-outlinesticky-scroll-performance-regressions" target="_blank" rel="noopener noreferrer">修复大纲/粘性滚动性能退化问题</a></span></a></h2><p>在过去几个月里，我们收到了关于笔记本编辑器性能退化的反馈。**这些退化很难准确定位，也不容易复现。感谢社区不断提供日志和反馈，我们发现这些退化来自大纲和粘滚动功能，因为我们对它们添加了新功能。这些问题已在此版本中修复。</p><p>我们感谢社区的反馈和耐心，我们会继续改进笔记本编辑器的性能。如果您继续遇到性能问题，请毫不犹豫地在 VS Code 仓库中提交新问题。</p><h2 id="快速搜索" tabindex="-1"><a class="header-anchor" href="#快速搜索"><span><a href="https://code.visualstudio.com/updates/v1_89#_quick-search" target="_blank" rel="noopener noreferrer">快速搜索</a></span></a></h2><p>快速搜索使您能够在工作区文件中快速执行文本搜索（使用 % 百分号前缀）。快速搜索不再是实验性的，所以试试吧！✨🔍</p><p>请注意，所有快速搜索命令和设置中不再包含“实验性”关键词在其标识符中。例如，命令 ID <code>workbench.action.experimental.quickTextSearch</code> 变为了 <code>workbench.action.quickTextSearch</code>。<strong>如果您的设置或按键绑定使用了这些旧的 ID，则这可能是相关的。</strong></p><h2 id="搜索树递归展开" tabindex="-1"><a class="header-anchor" href="#搜索树递归展开"><span><a href="https://code.visualstudio.com/updates/v1_89#_search-tree-recursive-expansion" target="_blank" rel="noopener noreferrer">搜索树递归展开</a></span></a></h2><p><strong>我们新增了一个上下文菜单选项，可以让您在搜索树中递归地打开所选的树节点。</strong></p><h2 id="⚠️-画布渲染器的弃用" tabindex="-1"><a class="header-anchor" href="#⚠️-画布渲染器的弃用"><span><a href="https://code.visualstudio.com/updates/v1_89#_-deprecation-of-the-canvas-renderer" target="_blank" rel="noopener noreferrer">⚠️ 画布渲染器的弃用</a></span></a></h2><p>该终端设备具有三种不同的渲染器：DOM 渲染器、WebGL 渲染器和画布渲染器。我们一直想要移除画布渲染器，但由于 DOM 渲染器性能不佳以及 WebKit 未实现 webgl2，我们被阻止了。<strong>这两个问题现在都已解决！</strong></p><p>在这个版本中，我们从备用链中移除了画布渲染器，因此只有在将 <code>terminal.integrated.gpuAcceleration</code> 设置显式设置为“canvas”时才启用它。**我们计划在下一个版本中彻底移除画布渲染器。<strong>如果当 <code>terminal.integrated.gpuAcceleration</code> 设置为“on”或“off”时出现问题，请告诉我们。</strong></p><h2 id="markdown-路径补全中的图像预览" tabindex="-1"><a class="header-anchor" href="#markdown-路径补全中的图像预览"><span><a href="https://code.visualstudio.com/updates/v1_89#_image-previews-in-markdown-path-completions" target="_blank" rel="noopener noreferrer">Markdown 路径补全中的图像预览</a></span></a></h2><p>VS Code 内置的 Markdown 工具为 Markdown 中的链接和图片提供路径补全。在完成对图像或视频文件的路径时，我们现在在完成详情中直接显示一个小预览。<strong>这可以帮助您更轻松地找到所需的图像或视频。</strong></p><h2 id="悬停以预览-markdown-中的图像和视频" tabindex="-1"><a class="header-anchor" href="#悬停以预览-markdown-中的图像和视频"><span><a href="https://code.visualstudio.com/updates/v1_89#_hover-to-preview-images-and-videos-in-markdown" target="_blank" rel="noopener noreferrer">悬停以预览 Markdown 中的图像和视频</a></span></a></h2><p>想要在不打开完整的 Markdown 预览的情况下快速预览图像或视频吗？现在，您可以将鼠标悬停在图像或视频路径上，以查看其小预览。</p><h2 id="改进的-markdown-标题重命名" tabindex="-1"><a class="header-anchor" href="#改进的-markdown-标题重命名"><span><a href="https://code.visualstudio.com/updates/v1_89#_improved-markdown-header-renaming" target="_blank" rel="noopener noreferrer">改进的 Markdown 标题重命名</a></span></a></h2><p>你知道吗，VS Code 内置的 Markdown 支持允许您使用 F2 重命名标题？这很有用，因为它还会自动更新所有链接到该标题的链接。<strong>在这个迭代中，我们改进了在 Markdown 文件中存在重复标题的重命名处理。</strong></p><p><strong>考虑 Markdown 文件：</strong></p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">#</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> Readme</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#D4976C;">-</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Example 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">](</span><span style="--shiki-light:#393A3490;--shiki-light-text-decoration:underline;--shiki-dark:#DEDCD590;--shiki-dark-text-decoration:underline;">#example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#D4976C;">-</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Example 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">](</span><span style="--shiki-light:#393A3490;--shiki-light-text-decoration:underline;--shiki-dark:#DEDCD590;--shiki-dark-text-decoration:underline;">#example-1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">##</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> Example</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">##</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> Example</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个示例标题具有相同的文本，但可以通过使用唯一的 ID（<code>＃example </code> 和 <code>＃example-1</code>）分别链接到每个标题。以前，如果将第一个示例标题重命名为第一个示例，<code>＃example</code> 链接将正确更改为 <code>＃first-example</code>，但 <code>＃example-1</code> 链接将不会更改。<strong>但是，在重命名后，<code>＃example-1</code> 不再是有效的链接，因为不再存在重复的示例标题。</strong></p><p>我们现在正确处理这种情况。例如，如果您将文档中的第一个 <code>## Example</code> 标题重命名为 <code>## First Example</code>，则新文档将是：</p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">#</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> Readme</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#D4976C;">-</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Example 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">](</span><span style="--shiki-light:#393A3490;--shiki-light-text-decoration:underline;--shiki-dark:#DEDCD590;--shiki-dark-text-decoration:underline;">#first-example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#D4976C;">-</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Example 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">](</span><span style="--shiki-light:#393A3490;--shiki-light-text-decoration:underline;--shiki-dark:#DEDCD590;--shiki-dark-text-decoration:underline;">#example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">##</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> First Example</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">##</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> Example</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，现在两个链接都已自动更新，以确保它们仍然有效！</p><h2 id="粘贴时自动更新的-markdown-链接" tabindex="-1"><a class="header-anchor" href="#粘贴时自动更新的-markdown-链接"><span><a href="https://code.visualstudio.com/updates/v1_89#_automatic-markdown-link-updates-on-paste" target="_blank" rel="noopener noreferrer">粘贴时自动更新的 Markdown 链接</a></span></a></h2><p>比方说，你正在撰写一些 Markdown 文档，然后意识到文档中的某一部分实际上应该放在另一个地方。于是，你将它复制并粘贴到另一个文件中。一切都很好，对吧？但是，如果复制的文本中包含任何相对路径链接、引用链接或图像，那么这些链接很可能会失效，你将不得不手动修复它们。这可能会很麻烦，但幸运的是，新的“粘贴后更新链接”功能来帮忙啦！</p><p>要启用此功能，只需将 <code>markdown.experimental.updateLinksOnPaste</code> 设置为 true。启用后，当您在当前编辑器的 Markdown 文件之间复制和粘贴文本时，VS Code 会自动修复所有相对路径链接、引用链接以及所有具有相对路径的图片/视频。</p><p><strong>粘贴后，如果您意识到您实际上想要插入您复制的确切文本，您可以使用粘贴控制切换回正常的复制/粘贴行为。</strong></p><h2 id="python-新的自动缩进设置" tabindex="-1"><a class="header-anchor" href="#python-新的自动缩进设置"><span><a href="https://code.visualstudio.com/updates/v1_89#_new-auto-indentation-setting" target="_blank" rel="noopener noreferrer">Python 新的自动缩进设置</a></span></a></h2><p>以前，Pylance 的自动缩进行为是通过 <code>editor.formatOnType</code> 设置来控制的，如果你想禁用自动缩进但启用其他支持工具的格式化，这可能会有问题。为了解决这个问题，Pylance 有自己的设置来控制其自动缩进行为：<code>python.analysis.autoIndent</code>，默认情况下是启用的。</p>`,44)])])}const l=s(t,[["render",r]]),h=JSON.parse('{"path":"/release_notes/fzpsrc67/","title":"VSCode 1.89 (2024 年 4 月)","lang":"zh-CN","frontmatter":{"title":"VSCode 1.89 (2024 年 4 月)","createTime":"2025/11/09 16:12:30","permalink":"/release_notes/fzpsrc67/","description":"主要内容摘抄自 VSCode 1.89 发行说明，文中“我们”即 VSCode 本地工作区扩展 本地工作区扩展首次在 VS Code 1.88 版本中推出，现已（v1.89）普遍可用。您现在可以直接将扩展包含在您的工作区中，并仅为该工作区安装它。此功能旨在满足您特定的工作区需求，并提供更加量身定制的开发体验。 要使用此功能，您需要将扩展放在您的工作区的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"VSCode 1.89 (2024 年 4 月)\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-09T13:10:08.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://sillot.hwd.deno.net/release_notes/fzpsrc67/"}],["meta",{"property":"og:site_name","content":"汐洛 🦢"}],["meta",{"property":"og:title","content":"VSCode 1.89 (2024 年 4 月)"}],["meta",{"property":"og:description","content":"主要内容摘抄自 VSCode 1.89 发行说明，文中“我们”即 VSCode 本地工作区扩展 本地工作区扩展首次在 VS Code 1.88 版本中推出，现已（v1.89）普遍可用。您现在可以直接将扩展包含在您的工作区中，并仅为该工作区安装它。此功能旨在满足您特定的工作区需求，并提供更加量身定制的开发体验。 要使用此功能，您需要将扩展放在您的工作区的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-09T13:10:08.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-09T13:10:08.000Z"}]]},"readingTime":{"minutes":7.06,"words":2119},"git":{"createdTime":1762675125000,"updatedTime":1762693808000,"contributors":[{"name":"Soltus","username":"Soltus","email":"83791825+Soltus@users.noreply.github.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Soltus?v=4","url":"https://github.com/Soltus"}],"changelog":[{"hash":"61c3a5bdf5ea53244def8d56f13ff815ac3de964","time":1762693808000,"email":"83791825+Soltus@users.noreply.github.com","author":"绛亽","message":"迁移"},{"hash":"e519b2f4e7198b680e2eadd44dfe9a2ae45b0870","time":1762686512000,"email":"83791825+Soltus@users.noreply.github.com","author":"绛亽","message":"迁移"},{"hash":"dfc7dcd61cd80357f1db099b0eed2ad7da5bb291","time":1762675125000,"email":"83791825+Soltus@users.noreply.github.com","author":"绛亽","message":"迁移"}]},"autoDesc":true,"filePathRelative":"col_doc/2_releaseNotes/VSCode/1_89.md","headers":[]}');export{l as comp,h as data};
