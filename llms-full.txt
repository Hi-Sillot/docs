---
url: /blog/iips7owi/index.md
---
# 1
11111111111111

---

---
url: /blog/ww97il94/index.md
---
# 2
2222222222

---

---
url: /demo/index.md
---
# Demo
* [bar](./bar.md)
* [foo](./foo.md)

---

---
url: /demo/ahqzfn0k/index.md
---
# SSR
这里展示一个通用模板，由于没有定义组件，所以永远不会加载成功。这是正常的，控制台报错也没有关系。

---

---
url: /demo/bar/index.md
---
# bar
[foo](./foo.md)

---

---
url: /demo/fjoaykji/index.md
---
孵化自

# 孵化自 sfj2ory3892&#x20;

---

---
url: /demo/foo/index.md
---
# foo
[bar](./bar.md)

打开  试试

6

6

6

6

6

6

6

6

6

6

---

---
url: /demo/fruyzo7c/index.md
---
# a
本人表达观点仅字面含义，非引战，非水军，非反串，仅为个人感想无任何衍生含义内容不代表任何其他团体个人，无任何隐喻，暗示，反串，碰瓷，蹭热度等想法。

本人家庭和睦安康、无任何心理或精神疾病，智力为正常水平。观点及言论仅代表我个人一点浅薄的看法，非专业学术内容仅为个人bb空间，部分内容仅为猜测不代表实际，与本人所在群体、父母亲朋、所在省市地区无关。如有不同观点欢迎礼貌讨论感谢指正。本言论不含有对任何群体的歧视，不含有任何挑起对立的含义。

本人认知范围浅薄，无专业团队，内容偏个人想法，如有误会歧义欢迎指正。内容如有雷同纯属巧合。如有疑惑欢迎私信质疑本人一一回复，因私信评论较多时间有限短期未回复不代表无视。未回复也可能是手滑没看到。

本人的表达能力一般，面部表情管理较差，如表情过于欠揍绝非恶意鄙视某个人、团体、群体的含义，评论区网友意见绝非本人想法，不代表本人意思，如有点赞到您不认可的内容纯属手滑，绝非故意针对你个人，你所在群体、团体、组织。

本人神经天马行空，常常脱离常识，如有歧义欢迎指正。

本人为地球人。热爱地球文化文明，绝无任何反人类倾向，本人承诺未向三体发送过地球坐标，未向任何外星人、异次元文明、其它宇宙、平行宇宙透露过地球信息，本人个人性别为男性，坚定支持男女平等，男女两字的排序不分前后，

本人用词较为网络通用口语，绝无任何恶意，绝无任何将严肃话题娱乐化的意图。

本人承诺热爱小动物，如把人比喻成狗仅通俗调侃，绝无任何践踏人类人格、尊严、人权等意图，绝无歧视动物的意图。

本人素质为平均素质，发表言论不具备任何专业性，仅供参考。

本人对自己发表内容会负所有责任。评论中如有不良言论，建议自行拉黑或举报处理，绝非我视而不见置之不理或认可不良内容。内容如有雷同纯属巧合。

---

---
url: /demo/h5947bgm/index.md
---
# Simple

---

---
url: /demo/x51nr8g9/index.md
---
# 我很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长
## 本人表达观点仅字面含义，非引战，非水军，非反串，仅为个人感想无任何衍生含义内容不代表任何其他团体个人，无任何隐喻，暗示，反串，碰瓷，蹭热度等想法。

## 本人家庭和睦安康、无任何心理或精神疾病，智力为正常水平。观点及言论仅代表我个人一点浅薄的看法，非专业学术内容仅为个人bb空间，部分内容仅为猜测不代表实际，与本人所在群体、父母亲朋、所在省市地区无关。如有不同观点欢迎礼貌讨论感谢指正。本言论不含有对任何群体的歧视，不含有任何挑起对立的含义。

## 本人认知范围浅薄，无专业团队，内容偏个人想法，如有误会歧义欢迎指正。内容如有雷同纯属巧合。如有疑惑欢迎私信质疑本人一一回复，因私信评论较多时间有限短期未回复不代表无视。未回复也可能是手滑没看到。

## 本人的表达能力一般，面部表情管理较差，如表情过于欠揍绝非恶意鄙视某个人、团体、群体的含义，评论区网友意见绝非本人想法，不代表本人意思，如有点赞到您不认可的内容纯属手滑，绝非故意针对你个人，你所在群体、团体、组织。

## 本人神经天马行空，常常脱离常识，如有歧义欢迎指正。

## 本人为地球人。热爱地球文化文明，绝无任何反人类倾向，本人承诺未向三体发送过地球坐标，未向任何外星人、异次元文明、其它宇宙、平行宇宙透露过地球信息，本人个人性别为男性，坚定支持男女平等，男女两字的排序不分前后，

## 本人用词较为网络通用口语，绝无任何恶意，绝无任何将严肃话题娱乐化的意图。

## 本人承诺热爱小动物，如把人比喻成狗仅通俗调侃，绝无任何践踏人类人格、尊严、人权等意图，绝无歧视动物的意图。

## 本人素质为平均素质，发表言论不具备任何专业性，仅供参考。

## 本人对自己发表内容会负所有责任。评论中如有不良言论，建议自行拉黑或举报处理，绝非我视而不见置之不理或认可不良内容。内容如有雷同纯属巧合。

---

---
url: /demo/yr9nbgg6/index.md
---
# veddio
测试 sillot-video-tabs:

可选平台

多个视频

只有一个视为非法

---

---
url: /develop_notes/17ta7xvx/index.md
---
# callout
> https://github.com/orgs/community/discussions/16925

```markdown
> [!NOTE]  
> Highlights information that users should take into account, even when skimming.

> [!TIP]
> Optional information to help a user be more successful.

> [!IMPORTANT]  
> Crucial information necessary for users to succeed.

> [!WARNING]  
> Critical content demanding immediate user attention due to potential risks.

> [!CAUTION]
> Negative potential consequences of an action.
```

> \[!NOTE]
> Highlights information that users should take into account, even when skimming.

> \[!TIP]
> Optional information to help a user be more successful.

> \[!IMPORTANT]
> Crucial information necessary for users to succeed.

> \[!WARNING]
> Critical content demanding immediate user attention due to potential risks.

> \[!CAUTION]
> Negative potential consequences of an action.

---

---
url: /develop_notes/2mjyk2bb/index.md
---
# 路径规范
为了保持目录结构的清晰和合理，我们建议第三方开发者在存储数据时尽量避免将数据放在 `widgets`或者 `templates`文件夹下，因为这可能会导致目录的混乱和不必要的复杂性。

相反，我们推荐将数据存储在以下目录中：

1. **`snippets`目录：** 此目录适合存储小片段或片段化的数据，例如代码片段、文本片段等。这样的数据可以被轻松地管理和访问，并且不会与模板或小部件相关联。
2. **`storage`目录：** 此目录适合存储较大或者持久化的数据，例如用户上传的文件、数据库备份等。这些数据通常不与特定的模板或小部件直接相关，因此存储在 `storage`目录下更加合适。

---

---
url: /develop_notes/3ix9ldrn/index.md
---
# 检查依赖升级
不建议使用 npm-check 等第三方包来检查依赖并养成习惯，pnpm outdated 足够好用，也支持多工作区检查 `pnpm outdated -r` 或者 `pnpm outdated --filter *`，你必须清楚自己升级了哪些依赖而不是一键升级完事，负起责任来。

---

---
url: /develop_notes/4vtlxsd0/index.md
---
# action 文件规范
## 步骤名称开头的 emoji

随着 action 文件越来越复杂，文件和 Github action 界面的可读性都不可避免面临一定程度的挑战，因此我们约定通过下面的 emoji 规范命名步骤，推荐搭配微软拼音输入法使用

1. ☄️ 彗星：检出仓库
2. 🔨 锤子：准备工具
3. 💫 头晕：获取值、字段、属性等
4. 📃 带卷边的页面：生成非日志、非持久化的输出
5. 🚩 三角旗：创建发布
6. ✅ 勾号按钮：检查
7. 📦 包裹：打包
8. ✍️ 写字：写入或修改文件
9. 🗑️ 垃圾桶：清理文件、目录；释放空间
10. 🔥 火焰：构建
11. 📤 发件箱：上传；发送
12. 💥 爆炸：运行脚本
13. 🌠 流星：签名
14. 🧲 磁铁：获取资产；下载
15. 🚀 安装依赖

---

---
url: /develop_notes/68f34q2g/index.md
---
# electron 调试
> \[!TIP]
> 通过 Debugtron 可查看 main.js 的 console 输出

开发调试使用下面的指令：

::: npm-to

```sh
npm run start
```

:::

或者

::: npm-to

```sh
npm run dlv
```

:::

---

---
url: /develop_notes/73ufmwl0/index.md
---
# fork
Fork 是 GitHub 提供的一种功能，允许用户复制一个项目到自己的账户下，以便进行修改和贡献。Fork 操作可以看作是创建一个项目的副本，用户可以在自己的副本上进行修改和开发，而不会影响到原始项目。

Fork 操作的具体步骤如下：

1. 登录到 GitHub 账户。
2. 在要 Fork 的项目页面上，点击右上角的 "Fork" 按钮。
3. 在弹出的对话框中，选择要将项目 Fork 到哪个账户下，然后点击 "Fork" 按钮。
4. Fork 操作完成后，用户可以在自己的账户下看到一个与原始项目相同的副本。用户可以在这个副本上进行修改和开发，而不会影响到原始项目。

### 注意事项

fork 分支如果希望持续与对应的上游分支保持同步，分支名称必须保持一致，否则只有创建时是复制的制定分支，后续目标会被强制改为上游默认分支

---

---
url: /develop_notes/cnyb10g5/index.md
---
# 标签
汐洛全矩阵仓库标签使用海文东标准+绛亽标准+汐洛标准

### 海文东标准

| 标 签 | 描 述 | 颜 色（不区分大小写） |
| --- | --- | --- |
|  | 移除废止 ❌ | #D9580B |
|  | 评估调研 🛸 | #2B405F |
|  | 修复错误 🩸 | #ff1a2a |
|  | 改进优化 🎢 | #1D1B0A |
|  | 插件扩展 🧩 | #5319E7 |
|  | 功能特性 🧮 | #006b75 |
|  | 破坏重构 ♻️ | #805D5B |
|  | 安全更新 ☢️ | #2D7207 |
|  | 闪亮之名 🍭 | #fafaaf |

### 绛亽标准

> 颜色均为 #131313

&#x20;[+DevEnv]
&#x20;[+Document]
&#x20;[+Feedback]
&#x20;[+HWD]
&#x20;[+Proxy]
&#x20;[+T]

[+DevEnv]: 开发环境相关

[+Document]: 文档相关

[+Feedback]: 用户反馈

[+HWD]: 海文东互联

[+Proxy]: 代理议题

[+T]: 新彖乄

---

---
url: /develop_notes/ecxm75jp/index.md
---
# 汐洛扩展（插件）
1. 汐洛绞架（规划中）
2. [VSCode](https://marketplace.visualstudio.com/items?itemName=Hi-Windom.sillot)
3. Obsidian（规划中）
4. Android Studio（规划中）
5. Chromium 浏览器（维护中）
6. Utools（规划中）
7. rubick（规划中）
8. KeePass 2（规划中）
9. Jupyter Lab（规划中）

---

---
url: /develop_notes/mkup4ddd/index.md
---
# mode
## 为什么某个包会被包含在模块依赖中

```bash
go mod why github.com/mitchellh/reflectwalk # 这个命令会显示一个依赖链
```

---

---
url: /develop_notes/mpln0ihj/index.md
---
# 初始化项目
::: npm-to

```sh
npm install -g yo generator-code
```

:::

* 使用 `yo code`命令生成一个新的扩展。

pnpm i -D @vscode/vsce 安装到插件项目

在 package.json 添加字段

```sh
"vsce": {
    "baseImagesUrl": "https://my.custom/base/images/url",
    "dependencies": false,
    "yarn": false
  }
```

编辑插件项目的 Readme.md 内容

运行 pnpm vsce package 打包

---

---
url: /develop_notes/nt53gf29/index.md
---
# git tag 和 branch 的区别以及使用场景
tag 对应某次 commit, 是一个点，是不可移动的。
branch 对应一系列 commit，是很多点连成的一根线，有一个HEAD 指针，是可以依靠 HEAD 指针移动的。

所以，两者的区别决定了使用方式，改动代码用 branch ,不改动只查看用 tag。

tag 和 branch 的相互配合使用，有时候起到非常方便的效果，例如 已经发布了 v1.0 v2.0 v3.0 三个版本，这个时候，我突然想不改现有代码的前提下，在 v2.0 的基础上加个新功能，作为 v4.0 发布。就可以 检出 v2.0 的代码作为一个 branch ，然后作为开发分支。

## tag 的简单使用

### 创建标签

需要说明的是，创建 tag 是基于本地分支的 commit，而且与分支的推送是两回事，就是说分支已经推送到远程了，但是你的 tag 并没有，如果把 tag 推送到远程分支上，需要另外执行 tag 的推送命令。

```bash
git tag <tagName> # 创建本地tag
git push origin <tagName> # 推送到远程仓库
```

若存在很多未推送的本地标签，你想一次全部推送的话，可以使用一下的命令：

```bash
git push origin --tags
```

以上是基于本地当前分支的最后的一个 commit 创建的 tag ，但是如果不想以最后一个，只想以某一个特定的提交为 tag ，也是可以的，只要你知道 commit 的 id。

```bash
git log --pretty=oneline # 查看当前分支的提交历史，里面包含 commit id
git tag -a <tagName> <commitId>
```

### 查看标签

查看本地某个 tag 的详细信息：

```bash
git show <tagName>
```

查看本地所有 tag ：

> 下面两个命令都可以

```bash
git tag
git tag -l
```

查看远程所有 tag：

```bash
git ls-remote --tags origin
```

### 删除标签

本地 tag 的删除：

```bash
git tag -d <tagName>
```

远程 tag 的删除：

```bash
git push origin :<tagName>
```

### 重命名标签

这个本质上是删除掉旧名字 tag ，然后再新建新名字 tag ,然后实现重命名的作用。

如果 tag 只存在本地，那么只需要删除本地的旧名字 tag ，然后新建新名字 tag：

```bash
git tag -d <oldTagName>
git tag <newTagName>
git push origin <newTagName> # 推送到远程仓库
```

若已经推送到远程了，那么不仅要删除本地的，还要删除远程的，再重新创建和推送：

```bash
git tag -d <oldTagName>
git push origin :<oldTagName>
git tag <newTagName>
git push origin <newTagName> # 推送到远程仓库
```

### 检出标签

命令如下：

```bash
git checkout -b <branchName> <tagName>
```

因为 tag 本身指向的就是一个 commit，所以和根据 commit id 检出分支是一个道理。
但是需要特别说明的是，如果我们想要修改 tag 检出代码分支，那么虽然分支中的代码改变了，但是 tag 标记的 commit 还是同一个，标记的代码是不会变的，这个要格外的注意。

## git分支删除后tag还在吗

当我们在Git中删除一个分支时，该分支上的提交历史将不再可见，但是这并不会影响标签（tag）的存在。标签是指向特定提交的静态引用，可以视为一个不可变的指针。

当我们删除一个分支时，标签仍然指向原始分支上的提交。这意味着标签仍然存在，并可以通过标签名称访问和使用。

参考：

1. https://www.cnblogs.com/konglxblog/p/16384162.html
2. https://worktile.com/kb/ask/283219.html#

---

---
url: /develop_notes/okpoken5/index.md
---
# 如何避免触发工作流
> https://github.blog/changelog/2021-02-08-github-actions-skip-pull-request-and-push-workflows-with-skip-ci/

GitHub Actions 现在通过在提交消息中查找一些常见关键字来支持跳过 push 和 pull\_request 工作流。

\*\[GitHub Actions 现在通过在提交消息中查找一些常见关键字来支持跳过 push 和 pull\_request 工作流]: GitHub Actions now supports skipping push and pull\_request workflows by looking for some common keywords in your commit message.

如果推送或 PR 的 HEAD 提交中的任何提交消息包含字符串 `[skip ci]` 、 `[ci skip]`、`[no ci]` 、 `[skip actions]` 或 `[actions skip]` 触发的 push 或 pull\_request 事件的工作流将被跳过。\[+jd2938yr1r23t34]

\[+jd2938yr1r23t34]: If any commit message in your push or the HEAD commit of your PR contains the strings `[skip ci]`, `[ci skip]`, `[no ci]`, `[skip actions]`, or `[actions skip]` workflows triggered on the push or pull\_request events will be skipped.

---

---
url: /develop_notes/q2h6avmy/index.md
---
# 多工作区支持
### 多工作区 pnpm -r 和 pnpm --filter \* 有什么区别

在 pnpm 中，使用 `pnpm -r` 和 `pnpm --filter *` 在多工作区（workspaces）项目中的行为实际上是相似的，但有一些微妙的区别。

1. `pnpm -r` 或 `pnpm --recursive`：这个命令会对所有的工作区执行操作。例如，`pnpm install -r` 会为每个工作区安装依赖项。这个命令通常用于批量操作，比如安装、更新或构建所有的工作区。
2. `pnpm --filter *`：这个命令也会对所有的 workspace 包执行操作，但是它有一些额外的灵活性。`--filter` 参数允许你指定更具体的包或工作区。例如，`pnpm install --filter package-name` 只会为特定的包安装依赖项。使用 `*` 作为过滤器会匹配所有的工作区，因此在这种情况下，它的效果和 `-r` 或 `--recursive` 是一样的。
   然而，`--filter` 参数的一个关键特性是它允许你使用 glob 模式来匹配工作区的名称，或者指定包的版本范围。这意味着你可以对特定的工作区执行操作，而不必影响其他的工作区。例如，`pnpm install --filter 'workspace-*'` 会匹配所有以 `workspace-` 开头的工作区。
   总的来说，如果你只是想要对所有工作区执行某个操作，`pnpm -r` 和 `pnpm --filter *` 可以互换使用。但如果你需要更细粒度的控制，`--filter` 提供了更多的灵活性和选择性。

---

---
url: /develop_notes/qdgrx1o2/index.md
---
# 序列化
## kotlin compose中使用@Serializable好还是@Parcelize好

在Kotlin的Compose框架中，数据序列化是一个重要的方面，尤其是在处理UI状态、持久化或跨组件传递数据时。`@Serializable`和 `@Parcelize`是两种常用的注解，用于实现数据序列化，但它们的使用场景和优势各不相同。
`@Serializable`是Kotlin标准库的一部分，它允许你轻松地将数据类对象转换为JSON格式，反之亦然。这对于网络请求、本地存储和与其他系统交换数据非常有用。`@Serializable`注解通过Kotlin的序列化库支持，可以处理复杂的数据结构和嵌套类，同时提供了灵活的定制选项，比如自定义序列化器和忽略某些属性。
另一方面，`@Parcelize`是Android KTX库的一部分，专为Android开发设计，用于实现Parcelable接口。Parcelable是一种高效的序列化机制，专门用于Android中的跨进程通信（IPC）。它比Serializable更快，因为它直接将数据序列化为字节流，适合在Android组件之间传递数据，如Intent和Bundle。
在决定使用哪个注解时，应考虑以下几点：

1. **性能需求**：如果你需要高效的跨进程通信，尤其是在Android应用中，`@Parcelize`可能是更好的选择。
2. **数据交换格式**：如果你需要将数据序列化为JSON或其他格式，或者需要与不支持Parcelable的系统交换数据，`@Serializable`更适合。
3. **平台兼容性**：`@Serializable`可以在任何支持Kotlin的平台中使用，而 `@Parcelize`仅限于Android。
4. **复杂性和灵活性**：如果你的数据结构复杂，需要更多的定制和灵活性，`@Serializable`提供了更多的选项。
   在实际应用中，你可能需要根据具体情况选择最合适的注解。例如，对于Compose中的状态管理，如果状态对象需要在Compose组件之间传递，并且需要跨进程传递，那么 `@Parcelize`可能是更好的选择。如果状态对象需要被持久化到本地存储，或者通过网络传输，那么 `@Serializable`可能更合适。
   总之，没有绝对的“好”与“坏”，应根据具体需求和应用场景来选择最合适的序列化方式。

由于 `@Parcelize`依赖于Android的Parcelable机制，它不适用于Kotlin的多平台项目，这些项目可能会针对除了Android之外的其他平台，如JVM、iOS、Linux等。在Kotlin的多平台项目中使用Compose时，如果您需要序列化数据，应该使用 `@Serializable`注解。`@Serializable`是Kotlin的跨平台序列化机制的一部分，它允许您在不同的平台之间轻松地序列化和反序列化数据。这意味着您可以在多平台项目中使用 `@Serializable`来序列化Compose中的状态对象，而不用担心平台兼容性问题。

更正：

`kotlinx.parcelize` 是在 Kotlin 1.4.30 版本中引入的，用于 Kotlin/Native 项目，允许开发者在 Kotlin/Native 中使用 Parcelable。Kotlin/Native 是 Kotlin 的一个版本，它可以将 Kotlin 代码编译成原生二进制代码，可以运行在没有虚拟机的系统上，比如 iOS、Linux、Windows、macOS 等。

`kotlinx.android.parcelize` 是专门为 Android 平台设计的，已经弃用。

---

---
url: /develop_notes/qx966bnk/index.md
---
# 代码审查
在软件开发过程中，我们强烈禁止以下类型的代码出现，以维护用户和团队的安全与信任：

1. **意义不明且没有注释的代码：** 所有代码都应具有明确的意义，并且应该进行适当的注释以解释其用途和功能。未经注释的代码将增加后续维护和理解的难度，影响团队的工作效率。
2. **获取用户敏感信息并上传的代码：** 禁止在未经用户同意的情况下获取用户的敏感信息，并且绝不应该将这些信息上传到任何地方，包括但不限于服务器或第三方服务。我们坚决维护用户的隐私和数据安全。
3. **擅自删除用户文件或数据的代码：** 绝不允许在没有用户明确授权的情况下擅自删除用户文件或数据。用户的数据应该受到尊重和保护，任何删除操作都应该经过合理的验证和用户确认。

---

---
url: /develop_notes/rcccglou/index.md
---
# 不推荐的API
* [Notifications | Electron (electronjs.org)](https://www.electronjs.org/docs/latest/tutorial/notifications) : Windows 平台受专注模式影响，通知的行为具有不确定性，无法保证通知触达用户。

---

---
url: /develop_notes/t6lghhgs/index.md
---
# 开发者行为规范
在软件开发过程中，我们鼓励每一位开发者严格遵守以下行为规范，以确保合作的高效性和团队之间的良好沟通：

1. **尊重源码并避免主观臆断：** 了解源码是准确理解软件功能和设计的关键。避免仅凭主观臆断对源码进行恶意评论，而是应该通过深入研究并提出准确的事实描述和疑问，以表达自己的观点。
2. **遵循不了解不评论原则：** 我们鼓励开发者在未充分了解相关事实之前，不要随意发表评论。应当通过研究和探索来获取必要的信息，以确保评论的准确性和客观性。
3. **以事实为依据提出疑问：** 当提出疑问或对软件特性进行评价时，应该基于准确的事实描述。通过以事实为依据的方式，能够更有效地与团队成员交流并推动问题的解决。
4. **尊重他人意见并建立良好沟通：** 尊重他人的意见和观点，建立基于合作和理解的良好沟通氛围。避免采取恶意批评或贬低他人的行为，以促进团队的凝聚力和合作精神。
5. **持续学习和改进：** 不断学习和改进是每一位开发者的责任。通过持续学习新知识和技能，以及反思和修正自己的行为，能够不断提升个人能力并推动团队的发展。

通过遵守以上行为规范，我们相信可以建立一个积极向上的开发环境，促进团队之间的合作和交流，共同推动软件项目的成功实现。

---

---
url: /develop_notes/uqo187ed/index.md
---
# Android Studio开发配置
版本下载可以在 [developer.android.com](https://developer.android.com/studio/archive?hl=en) 找到，必须是英文，其他语言可能尚未翻译该页面。
2024 年 7 月 25 日之前的一段时间构建的版本存在严重的内存泄露问题，尽快升级到 Android Studio Ladybug | 2024.1.3 Canary 3 之后的版本

汉化包可以在 [plugins.jetbrains.com](https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----/versions/) 找到，具体教程自行搜索。

## 插件

[ADB Wi-Fi](https://plugins.jetbrains.com/plugin/14969-adb-wi-fi)

解决原生WIFI调试不稳定的问题

[Atom Material Icons](https://plugins.jetbrains.com/plugin/10044-atom-material-icons)

美化图标

[CodeGeeX](https://plugins.jetbrains.com/plugin/20587-codegeex)

代码补全

[IKun Progress](https://plugins.jetbrains.com/plugin/20578-ikun-progress)

进度条美化

## 调试

调试汐洛安卓要求至少32GB内存。

---

---
url: /friends/index.md
description: 人生何处不相逢
---
# 友情链接
:::: demo-wrapper title="如何添加友链？"
::: info 编辑此页提交 `friends.md` 或 `issue` 添加/申请友链~！
:::
::::

---

---
url: /origin/index.md
---
# 原汐洛文档
?

---

---
url: /origin/35lpur95/index.md
---
# GitHub 下载量统计
## v0

### v0.31 -> v0.35

### v0.20 -> v0.30

### v0.9 -> v0.19

---

---
url: /origin/hu2pshp8/index.md
---
# docker
推荐使用 [1Panel:  现代化、开源的 Linux 服务器运维管理面板](https://github.com/1Panel-dev/1Panel) 部署汐洛镜像。

暴露端口 `58131`

Command 添加 `'--accessAuthCode=1234'`

---

---
url: /release_notes/index.md
---
# 发行文档
## VSCode

总是跟进最新正式版。对 VSCode 的兼容性要求主要取决于其 electron 捆绑的 Chromium 版本。

汐洛VSCode扩展目前不遵循汐洛矩阵的VSCode最低要求，而是使用最新正式版作为最低要求，这一情况可能持续到扩展迭代进入稳定期。

[VSCode版本更新官方说明](https://code.visualstudio.com/updates)

## electron

开发者渠道从 beta 3 开始跟进，以便尽快跟踪新版 Chromium 和 node.js

如果 beta 版本存在问题，则回退到正式版。electron-nightly 需要修改大量配置，因此汐洛不会使用。

汐洛不会在 electron 里耗费大量精力，因为 electron 并非汐洛的必要依赖，我们有计划脱离 electron 的依赖。

[electron release](https://releases.electronjs.org/releases)

## Chromium

综合评估当前新彖乄最低要求，兼容性在 https://caniuse.com/ 查看。

我们正在评估 Gecko

[Chromium release](https://developer.chrome.com/release-notes?hl=zh-cn) | [Chromium schedule](https://chromiumdash.appspot.com/schedule)

---

---
url: /release_notes/1efke9cr/index.md
---
# VSCode 1.95 (2024 年 10 月)
> 主要内容摘抄自 [VSCode 1.95 发行说明](https://vscode.js.cn/updates/v1_95)，文中“我们”即 VSCode

## [多个 GitHub 账户](https://vscode.js.cn/updates/v1_95#_multiple-github-accounts)

上个月的功能已升级为默认行为，现在可以在 VS Code 中同时登录多个 GitHub 账户。

## [设置编辑器中实验性和预览设置的指示器](https://vscode.js.cn/updates/v1_95#_settings-editor-indicator-for-experimental-and-preview-settings)

以前，在查看设置编辑器时，并不总是清楚哪些设置是实验性或预览性设置。为了突出实验性和即将推出的功能，设置编辑器现在在实验性和预览设置旁边显示指示器。您可以在设置编辑器搜索框中键入 `@tag:experimental` 或 `@tag:preview` 以相应地筛选设置。

扩展作者可以为其设置添加“实验性”或“预览”标签，以在设置编辑器中显示相应的指示器。

## [面板中的视图图标](https://vscode.js.cn/updates/v1_95#_view-icons-in-panel)

在工作台面板区域，视图通常以标签形式显示在标题栏中（例如，*终端* 或 *输出*）。然而，在较小的屏幕上，这些标签可能会超出可用空间，导致某些视图溢出到下拉菜单中。

为了解决这个问题，我们添加了一个新设置： 。禁用后，视图将显示为图标而不是标签，从而节省水平空间并减少溢出。

---

---
url: /release_notes/3l83tuw7/index.md
---
# VSCode 1.91 (2024 年 6 月)
> 主要内容摘抄自 [VSCode 1.91 发行说明](https://code.visualstudio.com/updates/v1_91)，文中“我们”即 VSCode

## [配置文件编辑器预览](https://code.visualstudio.com/updates/v1_91#_profiles-editor-preview)

在此里程碑中，我们引入了新的配置文件编辑器，使您能够在一个地方管理配置文件。此体验包括创建新配置文件、编辑和删除现有配置文件，以及导入和导出配置文件以与他人共享。在创建新配置文件时，您可以在保存之前预览配置文件并根据需要进行自定义。配置文件编辑器还使您能够使用特定配置文件打开新窗口，或将某个配置文件设置为新窗口的默认配置文件。

配置文件编辑器是此 `workbench.experimental.enableNewProfilesUI` 设置背后的一项实验性功能。启用后，您可以从窗口左下角的“设置”齿轮图标访问配置文件编辑器。

## [带有配置文件菜单项的新窗口](https://code.visualstudio.com/updates/v1_91#_new-window-with-profile-menu-item)

除了配置文件编辑器之外，我们还在文件菜单中添加了操作，以便打开具有特定配置文件的新窗口。使用文件>带有配置文件的新窗口菜单可以打开具有特定配置文件的新窗口。

## [扩展安装选项](https://code.visualstudio.com/updates/v1_91#_extension-install-options)

我们添加了更多选项，让您在安装扩展时有更大的灵活性：

* 安装扩展但不同步它。
* 安装扩展程序的特定版本。以前，您必须先安装扩展程序的最新版本，然后才能选择特定版本。

这些操作可以在扩展视图中的扩展的右键上下文菜单中找到

## [访问自定义标签中的文件扩展名](https://code.visualstudio.com/updates/v1_91#_access-file-extensions-in-custom-labels)

当您定义[自定义标签](https://code-visualstudio-com.translate.goog/docs/getstarted/userinterface?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN#_customize-tab-labels)时，您现在可以更灵活地使用语法访问单个文件扩展名 `${extname(N)}` 。此外，`${extname(N)}` 还支持负索引以按相反顺序捕获文件扩展名。要获取整个文件扩展名，请使用 `${extname}` 。

例如，对于文件tests/editor.test.ts：

```
    ${filename}=>editor
    ${extname}=>test.ts
    ${extname(0)}=>ts
    ${extname(1)}=>test
    ${extname(-1)}=>test
    ${extname(-2)}=>ts
```

## [取消设置主题颜色](https://code.visualstudio.com/updates/v1_91#_unset-a-theme-color)

如果主题设置了您不喜欢的颜色或边框，您现在可以使用default将其设置回原始值：

```json
  "workbench.colorCustomizations": {
      "diffEditor.removedTextBorder": "default"
  }
```

## [更改折叠占位符的颜色](https://code.visualstudio.com/updates/v1_91#_change-folding-placeholder-color)

折叠占位符（省略号）现在可以用颜色来设置主题 `editor.foldPlaceholderForeground` 。

## [保存时的代码操作](https://code.visualstudio.com/updates/v1_91#_code-actions-on-save)

通过此 `editor.codeActionsOnSave` 设置，您可以配置一组代码操作，这些操作会在您保存文件时自动应用，例如用于组织导入。我们改进了配置此设置的 IntelliSense，通过根据您的工作区文件和活动扩展提供可用的代码操作列表。

> 注意：尽管true和false目前仍是有效配置，但它们将被弃用，取而代之的是explicit、always和never。有关示例，请参阅[保存文档上的代码操作](https://code-visualstudio-com.translate.goog/docs/typescript/typescript-refactoring?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN#_code-actions-on-save)。

## [传入/传出更改图表预览](https://code.visualstudio.com/updates/v1_91#_incomingoutgoing-changes-graph-preview)

我们一直在探索使用一种替代的方式来可视化传入和传出的更改。此里程碑包含一个实验性功能，它使用图形来可视化传入和传出的更改。该图形包含当前分支、当前分支的上游分支以及可选的基础分支。图形的根是这些分支的共同祖先。 您可以通过使用 `scm.experimental.showHistoryGraph` 设置启用这种新的可视化效果。试用一下并告诉我们您的想法，因为我们将继续改进和扩展此可视化中的可用功能。

---

---
url: /release_notes/3n62qtji/index.md
---
# VSCode 1.102 (2025 年 6 月)
> 主要内容摘抄自 [VSCode 1.102 发行说明](https://vscode.js.cn/updates/v1_102)，文中“我们”即 VSCode

## [中键点击滚动](https://vscode.js.cn/updates/v1_102#_scroll-on-middle-click)

设置：&#x20;

只需单击或按住鼠标中键（滚轮）并移动即可滚动编辑器。

激活后，光标会变为平移图标，然后向上或向下移动鼠标会使编辑器在该方向上平滑滚动。滚动速度由您将鼠标从初始点击点移动的距离决定。释放鼠标中键或再次单击它可停止滚动并返回标准光标。

## [允许使用 vscode.openFolder 命令打开文件](https://vscode.js.cn/updates/v1_102#_allow-opening-files-when-using-vscodeopenfolder-command)

调用 `vscode.openFolder` 命令的扩展现在可以将 `filesToOpen?: UriComponents[]` 作为选项传递，以选择要在打开的工作区窗口中打开的文件。

---

---
url: /release_notes/3qfj3huz/index.md
---
# VSCode 1.78
> 主要内容摘抄自 [VSCode 1.78 发行说明](https://code.visualstudio.com/updates/v1_78)，文中“我们”即 VSCode

## [新的默认颜色主题](https://code.visualstudio.com/updates/v1_78#_new-default-color-themes)

新的“深色现代”和“浅色现代”主题取代了“深色+”和“浅色+”，成为新的默认深色和浅色主题。

## [从图像预览中复制图像](https://code.visualstudio.com/updates/v1_78#_copy-images-from-the-image-preview)

现在，您可以使用 Ctrl+C 或右键单击预览并选择“复制”，从内置图像预览中复制图像。复制的图像数据可以粘贴回 VS Code 或其他应用程序中。

## [独立颜色选择器](https://code.visualstudio.com/updates/v1_78#_standalone-color-picker)

现在可以启动独立的颜色选择器，以便插入和替换颜色。要打开颜色选取器，请从“命令面板”中选择“显示或聚焦独立颜色选取器”。

当扩展未提供任何颜色或颜色格式时，颜色选取器将回退到 CSS 格式的颜色。现在还可以可视化所有文件类型中 CSS 格式颜色的内联颜色装饰器。要显示这些装饰器，请启用编辑器：默认颜色装饰器 （  ） 设置。

## [Diff 算法改进](https://code.visualstudio.com/updates/v1_78#_diff-algorithm-improvements)

我们继续改进 VS Code 中的新 diff 算法，并弃用了旧算法。虽然旧算法仍然是差异编辑器的默认算法，但我们将慢慢将默认值更改为新算法并测量其性能。

您可以通过将  设置为 advanced（新的 diff 算法）或 legacy（默认）来覆盖默认值。

在许多情况下，新算法可以产生更好的差异，但对于某些文档来说，速度可能会更慢。

## [改进了扩展建议通知](https://code.visualstudio.com/updates/v1_78#_improved-extension-recommendations-notification)

扩展建议通知现在显示推荐扩展的发布者。这有助于您在安装扩展程序之前做出更明智的决定

## [通知已安装的已弃用扩展](https://code.visualstudio.com/updates/v1_78#_informing-about-installed-deprecated-extensions)

如果您安装了已被弃用的扩展，您现在将收到一条通知，通知您有关它并建议替代方案。对于每个已弃用的扩展，此内容仅显示一次。

## [GitHub 仓库规则集](https://code.visualstudio.com/updates/v1_78#_github-repository-rulesets)

VS Code 已经允许使用  设置定义分支保护。在这个里程碑中，我们添加了一项新的实验性功能，该功能使用最近发布的 GitHub 存储库规则集来确定分支是否受到保护。如果您使用的是 GitHub 仓库规则集，则可以使用  设置启用此功能。

## [editor/lineNumber/context 菜单](https://code.visualstudio.com/updates/v1_78#_editorlinenumbercontext-menu)

我们已经完成了 editor/lineNumber/context 菜单。这允许扩展作者向锚定到编辑器行号和字形边距的上下文菜单贡献操作。参与此菜单的操作在命令参数中接收行号，并且可以在其 when 子句中引用 editorLineNumber 上下文键。

## [Electron 22 更新](https://code.visualstudio.com/updates/v1_78#_electron-22-update)

在这个里程碑中，我们已经完成了使用自定义分配器作为扩展主机的实验，并准备将 Electron 22 捆绑到 VS Code Desktop 中。此更新附带 Chromium 108.0.5359.215 和 Node.js 16.17.1

---

---
url: /release_notes/3ss8iro1/index.md
---
# VSCode 1.84 (2023 年 10 月)
> 主要内容摘抄自 [VSCode 1.84 发行说明](https://code.visualstudio.com/updates/v1_84)，文中“我们”即 VSCode

## [自定义活动栏位置](https://code.visualstudio.com/updates/v1_84#_customize-activity-bar-position)

您现在可以将活动栏移动到侧栏的顶部。

当“活动”栏位于顶部时，“帐户”和“管理”按钮将移动到标题栏的最右侧。

注意：仅当启用自定义标题栏 （“window.titleBarStyle”： “custom”） 时才支持此功能。

## [隐藏编辑器选项卡](https://code.visualstudio.com/updates/v1_84#_hide-editor-tabs)

用户现在可以通过将  设置为 none 来隐藏编辑器选项卡。

## [最大化编辑组](https://code.visualstudio.com/updates/v1_84#_maximize-editor-group)

有一个新命令 `View: Toggle Maximize Editor Group` （Ctrl+K Ctrl+M） 以最大化编辑器组。这将隐藏所有其他组，并在标签栏中添加一个按钮，允许用户恢复以前的布局。如果将设置  设置为 `maximize` ，则用户可以双击编辑器选项卡以最大化和取消最大化编辑器组。

## [在“设置”编辑器中搜索类似设置](https://code.visualstudio.com/updates/v1_84#_similar-settings-search-in-the-settings-editor)

与命令面板一样，“设置”编辑器现在运行类似的设置搜索，以收集给定查询的更相关的结果。

该实现目前处于早期阶段，您可以期待在接下来的几次迭代中进行改进。

## [确认打开协议链接](https://code.visualstudio.com/updates/v1_84#_confirmation-for-opening-protocol-links)

当文件或工作区的协议链接在 VS Code 中打开时，现在将出现一个对话框，要求确认

协议链接可以指向本地文件（例如 `vscode://file/path/to/file` ）或远程文件（例如 `vscode://vscode-remote/ssh-remote+[USER@]HOST[:P ORT]/path/to/file` ）。对于每种情况，都有新的设置来禁用此行为：

* security.promptForLocalFileProtocolHandling - For local protocol links
* security.promptForLocalFileProtocolHandling - 用于本地协议链接
* security.promptForRemoteFileProtocolHandling- For remote protocol links
* security.promptForRemoteFileProtocolHandling- 用于远程协议链接

## [多文档高亮显示](https://code.visualstudio.com/updates/v1_84#_multidocument-highlighting)

通过设置 `editor.multiDocumentOccurrencesHighlight`（ 已`<a href="../1_85#多文档高亮显示">`变更`</a>`为  ），添加了对跨多个文档的代码高亮显示的初始支持。这种初始实现仅具有文本匹配项的功能，将来将支持语义突出显示。

## [使用 --force-if-includes 强制推送](https://code.visualstudio.com/updates/v1_84#_force-push-using-forceifincludes)

这个里程碑现在支持 --force-if-includes 选项，这是 Git 2.30 中添加的 --force-with-lease 的辅助选项。新选项可确保在检查远程引用尖端的提交后创建强制推送的提交，并减少了在启用自动获取时丢失提交的机会。您可以通过禁用  设置来禁用 --force-if-includes 的使用。

## [新的主题颜色](https://code.visualstudio.com/updates/v1_84#_new-theme-colors)

* textPreformat.background：预格式化文本段的背景颜色

## [每个名称的根文件夹图标](https://code.visualstudio.com/updates/v1_84#_root-folder-icons-per-name)

文件图标主题作者现在可以使用新属性 `rootFolderNames` 和 `rootFolderNamesExpanded` 为根文件夹定义特定于名称的图标。您可以查看文件图标主题指南以获取更多信息。

## [具有自定义排除规则的文件观察程序](https://code.visualstudio.com/updates/v1_84#_file-watchers-with-custom-exclude-rules)

在这个里程碑中，我们添加了一个建议的 API，用于创建完全控制排除规则的文件系统观察程序：

```ts
export interface FileSystemWatcherOptions {
  /**
   * An optional set of glob patterns to exclude from watching.
   * Glob patterns are always matched relative to the watched folder.
   */
  readonly excludes?: string[];
}

export function createFileSystemWatcher(
  pattern: RelativePattern,
  options?: FileSystemWatcherOptions
): FileSystemWatcher;
```

这个新的 API 使扩展能够完全控制文件观察程序，无论它是递归观察器还是非递归观察程序，也无论它是想在工作区内部还是外部观看。用户或默认配置的文件监视排除规则将不适用，因此您可以确保仅接收您订阅的事件。

## [Windows 32 位支持结束](https://code.visualstudio.com/updates/v1_84#_windows-32bit-support-ends)

不再支持 Windows 32 位 VS Code。如果您仍在使用 VS Code 的 32 位版本，则应更新到 64 位版本。

## [适用于 Java 的 Gradle](https://code.visualstudio.com/updates/v1_84#_gradle-for-java)

借助改进的 [Gradle for Java 扩展](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-gradle) ，VS Code 中的 Java 开发变得更加容易。由于采用了构建服务器协议 （BSP），预发布版本对构建 Gradle 项目有了更好的支持。与 VS Code 中使用的其他协议（例如语言服务器协议 （LSP））类似，BSP 在开发环境和构建工具（如 Gradle）之间提供了一个抽象层。

---

---
url: /release_notes/6bmw9z4x/index.md
---
# VSCode 1.68
> 主要内容摘抄自 [VSCode 1.68 发行说明](https://code.visualstudio.com/updates/v1_68)，文中“我们”即 VSCode

## [“问题”面板表格视图](https://code.visualstudio.com/updates/v1_68#_problems-panel-table-view)

在这个里程碑中，我们为用户添加了一项新功能，可以在树和表之间切换“问题”面板的查看模式。与树状视图相比，该表显示每个问题的源（语言服务或扩展），这使用户可以按其源筛选问题。

## [已弃用的扩展](https://code.visualstudio.com/updates/v1_68#_deprecated-extensions)

在此里程碑中，我们添加了对 VS Code 中已弃用扩展的支持。

注意：已弃用的扩展列表由 VS Code 维护。如果您认为应该弃用某个扩展，请在此[讨论](https://github.com/microsoft/vscode-discussions/discussions/1)中发表评论与我们联系。

## [赞助扩展](https://code.visualstudio.com/updates/v1_68#_sponsoring-extensions)

VS Code 现在允许用户赞助他们最喜欢的扩展。当扩展可以被赞助时，VS Code 将在扩展视图详细信息页面中呈现一个赞助按钮。“赞助者”按钮会将您定向到扩展程序的赞助 URL，您可以在其中提供支持。请参阅[扩展包赞助](https://code.visualstudio.com/updates/v1_68#_extension-sponsorship)，了解如何为扩展选择启用此功能。

## [在资源管理器中基于 .gitignore 隐藏文件](https://code.visualstudio.com/updates/v1_68#_hide-files-in-explorer-based-on-gitignore)

文件资源管理器现在支持解析和隐藏 .gitignore 文件排除的文件。这可以通过  设置来启用。此设置与  一起使用，以在资源管理器中隐藏不需要的文件。

注意：此时，否定的 globs（ 例如 `!package.json` ）是不可解析的。

## [Git：分支前缀](https://code.visualstudio.com/updates/v1_68#_git-branch-prefix)

为了使创建新分支的过程更加顺畅，有一个新设置  ，它指定在创建新分支时用作前缀的字符串。

\==推荐用于文件夹级而不是工作空间级或者用户级=={.tip}

## [Git：分支名称生成](https://code.visualstudio.com/updates/v1_68#_git-branch-name-generation)

新设置  将使 VS Code 在创建新分支时建议随机分支名称。随机名称是从字典中生成的，您可以通过  设置进行控制。支持的词典包括：形容词（默认）、动物（默认）、颜色和数字。

\==不支持自定义感觉没什么用=={.danger}

## [Git：分支保护](https://code.visualstudio.com/updates/v1_68#_git-branch-protection)

使用新的  设置，您可以配置要保护的特定分支。VS Code 将避免直接在受保护的分支上提交，并将为你提供创建新分支以提交到它的机会。您可以使用  设置来微调此行为。

## [GitHub：拉取请求模板支持](https://code.visualstudio.com/updates/v1_68#_github-pull-request-template-support)

GitHub 扩展现在可以理解[拉取请求模板](https://docs.github.com/communities/using-templates-to-encourage-useful-issues-and-pull-requests/creating-a-pull-request-template-for-your-repository)，并在从新分叉的存储库创建 PR 时将它们用作基础。

## [转到源定义](https://code.visualstudio.com/updates/v1_68#_go-to-source-definition)

VS Code 持续时间最长、最受好评的功能请求之一是让 VS Code 导航到来自外部库的函数和符号的 JavaScript 实现。目前，“转到定义”跳转到定义目标函数或符号类型的类型定义文件（.d.ts文件）。如果您需要检查这些符号的类型或文档，但隐藏了代码的实际实现，这将非常有用。当前的行为也使许多 JavaScript 用户感到困惑，他们可能无法理解 .d.ts 的 TypeScript 类型。

虽然将 Go to Definition 更改为导航到符号的 JavaScript 实现听起来很简单，但此功能请求打开这么久是有原因的。JavaScript（尤其是许多库附带的编译 JavaScript）比.d.ts更难分析。尝试分析node\_modules下的所有 JavaScript 代码既会很慢，还会大大增加内存使用量。此外，还有许多 JavaScript 模式是 VS Code IntelliSense 引擎无法理解的。

这就是新的“转到源定义”命令的用武之地。当您从编辑器上下文菜单或命令面板运行此命令时，TypeScript 将尝试跟踪符号的 JavaScript 实现并导航到它。这可能需要几秒钟，我们可能并不总是得到正确的结果，但它在许多情况下应该很有用。

我们正在积极改进此功能，因此请在您的代码库中尝试一下并[分享您的反馈](https://github.com/microsoft/TypeScript/issues/49003)。

## [Group aware Organize Imports](https://code.visualstudio.com/updates/v1_68#_group-aware-organize-imports)

## [Markdown 链接验证](https://code.visualstudio.com/updates/v1_68#_markdown-link-validation)

## [合并编辑器](https://code.visualstudio.com/updates/v1_68#_merge-editor)

我们已经开始致力于提供更好的合并体验。现在还处于早期阶段，我们还没有准备好接受反馈，但您可以通过 `git.experimental.mergeEditor` 尝试一下。启用此功能后，具有合并冲突的文件将在新的合并编辑器中打开，从而简化解决冲突的过程。

## [Inline Completions Finalization](https://code.visualstudio.com/updates/v1_68#_inline-completions-finalization)

我们已经完成了 Inline Completions API。这允许扩展提供与建议小部件分离的内联完成。内联完成将呈现为已被接受的格式，但颜色为灰色。用户可以循环浏览建议并使用 Tab 键接受它们。使用 Inline Completions 的示例扩展是 GitHub Copilot。有关详细信息，请参阅vscode.d.ts文件，其中 API 的入口点为 [languages.registerInlineCompletionItemProvider](https://github.com/microsoft/vscode/blob/e3a8e502ad7263836d0bc34cbcefbfc7bd65104f/src/vscode-dts/vscode.d.ts#L12357) 。

## [InputBox 验证消息严重性最终确定](https://code.visualstudio.com/updates/v1_68#_inputbox-validation-message-severity-finalization)

我们的 InputBox API（通过 `window.showInputBox` 和 `window.createInputBox` ）已经完成，用于[提供用户输入验证的严重性](https://github.com/microsoft/vscode/blob/main/src/vscode-dts/vscode.d.ts#L1990-L2002)。

例如，如果要根据用户的输入向用户显示信息消息，则验证消息可以返回：

```js
{
  message: 'this is an info message';
  severity: InputBoxValidationSeverity.Info;
}
```

## [基于时间线视图的扩展激活](https://code.visualstudio.com/updates/v1_68#_extension-activation-based-on-timeline-view)

当时间线视图可见时，已添加新的激活事件。此事件 `onView:timeline` 可由任何扩展使用，对于实现建议的 Timeline API 的扩展最有用。

## [扩展赞助](https://code.visualstudio.com/updates/v1_68#_extension-sponsorship)

在这个里程碑中，我们在扩展的package.json中引入了一个赞助者字段，允许扩展选择加入赞助。sponsor 对象有一个 url 字段，用于扩展作者的赞助链接。例如：

```json
"sponsor": {
    "url": "https://github.com/sponsors/nvaccess"
}
```

## [复制粘贴 API](https://code.visualstudio.com/updates/v1_68#_copy-paste-api)

新的 documentPaste API 提案允许扩展挂接到文本编辑器内的复制和粘贴中。这可用于修改插入到粘贴上的文本。扩展还可以在复制文本时存储元数据，并在粘贴时使用此元数据（例如，在两个代码文件之间粘贴时引入导入）。

[文档粘贴扩展示例](https://github.com/microsoft/vscode-extension-samples/tree/main/document-paste)演示了此 API 的操作：

```ts
/**
 * Provider that maintains a count of the number of times it has copied text.
 */
class CopyCountPasteEditProvider implements vscode.DocumentPasteEditProvider {
  private readonly countMimeTypes = 'application/vnd.code.copydemo-copy-count';

  private count = 0;

  prepareDocumentPaste(
    _document: vscode.TextDocument,
    _range: vscode.Range,
    dataTransfer: vscode.DataTransfer,
    _token: vscode.CancellationToken
  ): void | Thenable<void> {
    dataTransfer.set(this.countMimeTypes, new vscode.DataTransferItem(this.count++));
  }

  async provideDocumentPasteEdits(
    _document: vscode.TextDocument,
    range: vscode.Range,
    dataTransfer: vscode.DataTransfer,
    token: vscode.CancellationToken
  ) {
    const countDataTransferItem = dataTransfer.get(this.countMimeTypes);
    if (!countDataTransferItem) {
      return undefined;
    }

    const textDataTransferItem = dataTransfer.get('text/plain') ?? dataTransfer.get('text');
    if (!textDataTransferItem) {
      return undefined;
    }

    const count = await countDataTransferItem.asString();
    const text = await textDataTransferItem.asString();

    // Build a snippet to insert
    const snippet = new vscode.SnippetString();
    snippet.appendText(`(copy #${count}) ${text}`);

    return new vscode.SnippetTextEdit(range, snippet);
  }
}

vscode.languages.registerDocumentPasteEditProvider(
  { language: 'markdown' },
  new CopyCountPasteEditProvider()
);
```

---

---
url: /release_notes/7ipk4e7w/index.md
---
# VSCode 1.100 (2025 年 4 月)
> 主要内容摘抄自 [VSCode 1.100 发行说明](https://vscode.js.cn/updates/v1_100)，文中“我们”即 VSCode

## [.\*.env 文件的默认语法高亮](https://vscode.js.cn/updates/v1_100#_default-syntax-highlighting-for-env-files)

名称格式为 `.*.env` 的文件现在会像 `.ini` 文件一样进行语法高亮显示。

## [扩展的 ESM 支持](https://vscode.js.cn/updates/v1_100#_esm-support-for-extensions)

NodeJS 扩展主机现在支持使用 JavaScript 模块 (ESM) 的扩展。它所需要的只是您的扩展的 package.json 文件中的 `"type": "module"` 条目。有了它，JavaScript 代码可以使用 import 和 export 语句，包括特殊模块 `import('vscode')` 。在此处找到一个示例：https://github.com/jrieken/vscode-esm-sample-extension。

---

---
url: /release_notes/81vz2pbm/index.md
---
# VSCode 1.67
> 主要内容摘抄自 [VSCode 1.67 发行说明](https://code.visualstudio.com/updates/v1_67)，文中“我们”即 VSCode

## [资源管理器文件嵌套](https://code.visualstudio.com/updates/v1_67#_explorer-file-nesting)

资源管理器现在支持根据其名称嵌套相关文件。有几种设置可以控制此行为：

* &#x20;\- 控制是否启用大型文件嵌套。它可以全局设置，也可以针对特定工作区进行设置。
* &#x20;\- 控制默认情况下是否展开嵌套文件。
* &#x20;\- 控制文件的嵌套方式。默认配置为 TypeScript 和 JavaScript 项目提供嵌套智能，但建议您修改此配置以适应您自己的项目结构。

文件嵌套已通过实验设置进行了多次迭代。现在的行为基本没有变化，但文件操作除外。实验性设置 `explorer.experimental.fileNesting.operateAsGroup` 已被移除，支持在折叠时将嵌套视为一个组，但在其他情况下将嵌套视为单个实体。这意味着，如果您想复制、剪切、拖动或删除整个嵌套文件堆栈，您可以折叠嵌套，然后将其作为单个实体进行操作。当嵌套元素展开时，所选内容将照常运行。

## [重构后保存文件](https://code.visualstudio.com/updates/v1_67#_save-files-after-refactoring)

重构（如重命名）通常会修改多个文件，并留下未保存的更改（脏）。外部开发工具通常需要保存这些文件。为了简化此工作流，有一个新设置  ，该设置默认为 true，并控制是否应自动保存重构中的文件。

## [在编辑器限制中排除脏编辑器](https://code.visualstudio.com/updates/v1_67#_exclude-dirty-editors-in-editor-limit)

新设置  控制打开的编辑器的最大数量是否应排除脏编辑器以计入配置的限制。默认情况下，该设置处于禁用状态 （false）。

## [将“未提交的更改”恢复到时间线](https://code.visualstudio.com/updates/v1_67#_bring-back-uncommitted-changes-to-timeline)

> 看不出来变化

当我们上个月引入本地历史记录功能时，我们从 Git 时间线提供程序中删除了未提交的更改条目，因为它感觉有点多余。但是，一些用户在此时间线条目中看到了真正的价值，现在您可以通过相应地配置新的  设置来恢复它。

## [打开失败时的新编辑器占位符](https://code.visualstudio.com/updates/v1_67#_new-editor-placeholder-when-opening-fails)

当编辑器无法打开时，VS Code 将不再显示通知，并显示之前打开的编辑器。取而代之的是，有一个通用占位符，其中包含错误消息，在某些情况下，还有解决错误的操作。

## [显示无效或不兼容的扩展](https://code.visualstudio.com/updates/v1_67#_show-invalid-or-incompatible-extensions)

“扩展”视图现在在“已安装的扩展”列表中显示无效或不兼容的扩展，并显示错误状态。例如，如果你的 VS Code 版本是 1.67.0-insider，并且你已安装需要 VS Code 版本 1.68.0 的扩展，则它将以不兼容的错误状态显示在列表中。

## [退出前确认](https://code.visualstudio.com/updates/v1_67#_confirm-before-quit)

可以将新设置  配置为在退出应用程序之前显示确认对话框。

注意：该设置并非全新，在 VS Code for Web 中已提供一段时间。

## [在新窗口中处理 URI](https://code.visualstudio.com/updates/v1_67#_handle-uri-in-new-window)

每当 VS Code URI 包含查询参数 `windowId=_blank` 时，VS Code 将在新窗口中处理它。示例：`vscode://vscode.git/clone?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Fvscode-vsce.git&windowId=_blank` 。

## [默认情况下启用括号对着色](https://code.visualstudio.com/updates/v1_67#_bracket-pair-colorization-enabled-by-default)

鉴于 1.60 版本中引入的新括号对着色功能的积极反馈，我们默认启用括号对着色。

可以通过将 `editor.bracketPairColorization.enabled` 设置为 `false` 来禁用括号对着色。

也可以仅针对特定语言禁用括号对着色：

```json
"[typescript]": {
  "editor.bracketPairColorization.enabled": false,
},
```

## [TextMate 语法可以将标记标记为不平衡](https://code.visualstudio.com/updates/v1_67#_textmate-grammars-can-mark-tokens-as-unbalanced)

## [新的括号匹配算法](https://code.visualstudio.com/updates/v1_67#_new-bracket-matching-algorithm)

## [Bracket guide improvements](https://code.visualstudio.com/updates/v1_67#_bracket-guide-improvements)

## [Toggle inlay hints](https://code.visualstudio.com/updates/v1_67#_toggle-inlay-hints)

## [改进了内联建议](https://code.visualstudio.com/updates/v1_67#_improved-inline-suggestions)

## [将文本拖放到编辑器中](https://code.visualstudio.com/updates/v1_67#_drag-and-drop-text-into-editor)

您现在可以将文本从其他应用程序拖放到文本编辑器中。拖动时，虚线光标会显示文本的插入位置。

## [扩展的远程源提供商 API](https://code.visualstudio.com/updates/v1_67#_expanded-remote-source-providers-api)

Git 扩展 API 现在允许注册或显示远程源提供程序的扩展提供有关远程源的更丰富的信息。

远程源提供商现在可以为各个远程源设置描述和图标。此外，提供商可以选择性地指定最新的远程源。它们显示在选取器的顶层，以便于访问，如果提供了时间戳，则按时间戳排序。

## [Markdown：查找对标题的所有引用](https://code.visualstudio.com/updates/v1_67#_markdown-find-all-references-to-reference-links)

VS Code 现在支持在 Markdown 文件中运行标头的“查找所有引用”。这使您可以查看当前工作区中使用给定标题的所有位置，包括从其他 Markdown 文件指向它的链接。

首先，将光标放在标题本身或指向标题的链接的片段部分（例如，在 `[链接文本](#_some-header)` 或 `[链接文本](/path/to/file#some-header)`  中 `#some-header` ），然后运行“查找所有引用”。

这将在“引用”视图中显示所有引用。如果您更喜欢其他视图，还可以使用“查看引用”或“转到引用”命令。

## [Markdown：查找引用链接的所有引用](https://code.visualstudio.com/updates/v1_67#_markdown-find-all-references-to-reference-links)

## [Markdown：查找对文件的所有引用](https://code.visualstudio.com/updates/v1_67#_markdown-find-all-references-to-files)

## [Markdown：查找对 URL 的所有引用](https://code.visualstudio.com/updates/v1_67#_markdown-find-all-references-to-urls)

## [Markdown：重命名标题](https://code.visualstudio.com/updates/v1_67#_markdown-rename-headers)

曾经更改过 Markdown 文件中的标题，却意识到您还不小心破坏了指向它的所有链接吗？这就是我们对 Markdown 的新重命名支持可以提供帮助的地方。

首先，将光标放在标题上，然后按 F2 开始重命名。输入标题的新文本，然后按 Enter 接受。这既会更新当前标头，也会更新当前工作区中指向它的所有已知链接。

## [Markdown：重命名引用链接](https://code.visualstudio.com/updates/v1_67#_markdown-rename-reference-links)

## [Markdown：重命名文件](https://code.visualstudio.com/updates/v1_67#_markdown-rename-files)

## [关闭 JSON 验证](https://code.visualstudio.com/updates/v1_67#_json)

新设置  允许您关闭 JSON 验证。

## [设置配置文件](https://code.visualstudio.com/updates/v1_67#_settings-profile)

在此里程碑中，我们引入了设置配置文件，它是设置、扩展和 UI 自定义项的集合。如果自定义了 VS Code，现在可以将自定义项导出到设置配置文件 （mysetup.code-profile），并将其保存到计算机并与他人共享。

## [选项卡 API](https://code.visualstudio.com/updates/v1_67#_tab-api)

我们已经完成了选项卡 API 的只读端（也支持关闭选项卡），这标志着我们最受好评的议题之一 [microsoft/vscode#15178](https://github.com/microsoft/vscode/issues/15178) 的完成。这将公开信息，例如有多少组、打开了哪些选项卡、哪些选项卡处于活动状态、选项卡代表什么类型的编辑器等等！有关详细信息，请参阅vscode.d.ts文件，其中 API 的入口点是 window.tabGroups。

## [支持非递归工作区文件观察程序](https://code.visualstudio.com/updates/v1_67#_support-for-nonrecursive-workspace-file-watchers)

在之前的里程碑中，我们宣布 createFileSystemWatcher API 可用于监视磁盘上的任何文件夹，只要该文件夹不在打开的工作区内即可。现在，我们放宽了此限制，并允许非递归文件观察者在任何地方访问，甚至在打开的工作区内也是如此。非递归观察程序的优点是，为排除 （files.watcherExclude） 配置的设置不适用，因此您可以确保文件观察程序仅针对您订阅的路径发出。

我们正在努力为递归观察器提供全面支持，并为扩展提供自定义排除规则，因此请继续关注更多内容！

---

---
url: /release_notes/ayh65x5i/index.md
---
# VSCode 1.75
> 主要内容摘抄自 [VSCode 1.75 发行说明](https://code.visualstudio.com/updates/v1_75)，文中“我们”即 VSCode

## [配置文件](https://code.visualstudio.com/updates/v1_75#_profiles)

我们很高兴地宣布，配置文件功能现已在 VS Code 中正式发布。配置文件可以包含扩展、设置、键盘快捷键、UI 状态、任务和用户代码段。您可以为不同的开发方案（如数据科学、文档编写）或多种编程语言（如 Python 或 Java）自定义 VS Code。如果您根据工作流（例如“工作”或“演示”）有不同的 VS Code 设置，您也可以将它们另存为不同的配置文件。您可以打开多个工作区（文件夹），同时应用不同的配置文件。

## [打开大文件的新确认](https://code.visualstudio.com/updates/v1_75#_new-confirmation-to-open-large-files)

为了防止意外打开非常大的文件，尤其是在远程环境中，由于网络传输可能会产生实际成本，在打开文件之前会显示确认。可以通过新的  设置修改该限制，并且根据打开的本地文件和远程文件具有不同的默认值。

## [文件观察器支持 files。watcher排除 glob 模式](https://code.visualstudio.com/updates/v1_75#_file-watcher-supports-fileswatcherexclude-glob-patterns)

`files.watcherExclude` 设置支持 glob 模式，以实现文件观察程序的强大排除规则。但是，用于文件监视的库本身并未支持 glob 模式。在这个里程碑中，我们贡献了对 glob 模式的支持，以实现更高效的资源使用，尤其是在 Linux 上。

## [建议选择模式](https://code.visualstudio.com/updates/v1_75#_suggest-selection-mode)

有一个新设置 （），允许您配置是在键入时自动选择建议还是通过触发字符自动选择建议。

默认设置是始终选择最佳建议，以便按 Enter 或 Tab 键插入该建议。如果您不希望选择建议，请将值设置为 never、whenQuickSuggestion 或 whenTriggerCharacter。使用这些设置值时，建议仍会显示，但不会自动选择，您可以使用箭头键选择一个。

请注意，此设置仅适用于自动建议，不适用于通过 Ctrl+空格键明确触发建议时显示的建议。

## [颜色装饰器限制](https://code.visualstudio.com/updates/v1_75#_color-decorators-limit)

编辑器中显示的颜色装饰器数量限制为 500 个。这是为了防止在打开包含大量颜色的文件时出现性能问题。现在可以通过  设置来配置此限制。

## [重新设计的内联建议工具栏](https://code.visualstudio.com/updates/v1_75#_redesigned-inline-suggestions-toolbar)

在这个里程碑中，我们重新设计了内联建议工具栏，使其更紧凑、更易于使用。它具有一些按钮，可以快速循环浏览替代建议，并完全或逐字接受建议。

设置 `"editor.inlineSuggest.showToolbar": "always"` 可用于在内联建议可用时始终显示工具栏。

我们还添加了默认键绑定，用于逐字接受/撤消建议（Ctrl+左箭头/右箭头）。

## [源代码管理新命令](https://code.visualstudio.com/updates/v1_75#_new-commands)

Git 2.35 为 git stash 命令引入了新的 --staged 模式。通过这种新模式，您可以轻松地仅存储暂存的更改。如果您的 Git 版本支持此新模式，则可以使用新的 `Git: Stash Staged` 命令来利用它。

VS Code 已经支持使用 `Git: Delete Tag` 命令删除本地标签。在这个里程碑上，我们启用了使用新的 `Git: Delete Remote Tag` 命令删除远程标记的功能。

## [父文件夹中的 Git 存储库](https://code.visualstudio.com/updates/v1_75#_git-repositories-in-parent-folders)

VS Code 使用 git rev-parse --show-toplevel 来确定 Git 仓库的根。在大多数情况下，Git 存储库的根目录位于工作区内部，但在某些情况下，Git 仓库的根目录位于工作区的父文件夹或打开的文件中。虽然在工作区的父文件夹中打开 Git 存储库或打开的文件对于高级用户来说是一个很棒的功能，但它可能会让新用户感到困惑。我们已经看到一些案例，在这些案例中，这种混淆导致丢弃这些 Git 存储库的更改，从而导致数据丢失。

为了避免混淆并降低数据丢失的风险，从此里程碑开始，VS Code 将在源代码管理视图中显示通知和新的欢迎视图，并且不会自动从工作区的父文件夹和打开的文件打开 Git 存储库。

“打开存储库”按钮将打开一个“快速选择”，其中包含在工作区的父文件夹或打开的文件中发现的所有 Git 存储库的列表。从父文件夹打开 Git 存储库的选择会被记住。

用户可以使用 `git.openRepositoryInParentFolders` 设置来控制如何处理父文件夹中的 Git 仓库。想要恢复旧行为的用户可以将 `git.openRepositoryInParentFolders` 设置设置为始终。

## [源代码管理命令禁用](https://code.visualstudio.com/updates/v1_75#_command-disablement)

根据 Git 仓库的大小或是否存在各种 Git 钩子，某些 Git 操作可能需要很长时间才能完成。我们过去已经看到，在前一个命令仍在进行时启动命令可能会导致意外结果（例如，在提交操作进行时丢弃对文件的更改）。

为了防止这种情况，我们将禁用大多数 Git 命令，同时进行以下操作：Checkout、Commit、Push 和 Pull。这意味着，在运行这些操作时，大多数 Git 命令将不会显示在命令面板中，并将在源代码管理视图和状态栏中被禁用。

## [同步固定扩展版本](https://code.visualstudio.com/updates/v1_75#_sync-pinned-extension-versions)

“设置同步”现在将同步固定的扩展版本。这意味着，当您在一台计算机上安装扩展的特定版本时，它将固定到您同步到的所有其他计算机上的该版本。

## [扩展注册设置可声明忽略同步](https://code.visualstudio.com/updates/v1_75#_ignore-a-setting-to-sync)

现在，在注册设置时，默认情况下，您可以使用 `ignoreSync` 属性从“设置同步”中隐藏设置。这对于不打算在计算机之间同步的设置非常有用。

## [GB18030认证](https://code.visualstudio.com/updates/v1_75#_gb18030-certification)

VS Code 现已获得 GB18030 认证 - 这意味着中国政府内部的认证委员会已确认 VS Code 可以正确表示所有中文字符。该测试涵盖了所有内置的使用场景。

## [迁移到 ESM](https://code.visualstudio.com/updates/v1_75#_migrating-to-esm)

我们已经开始了将代码库迁移到 ESM 的旅程。VS Code 项目早于原生模块 （ESM），我们目前一直在使用异步模块系统 （AMD）。AMD为我们提供了很好的服务，但现在是时候继续前进了。我们已经开始将我们的代码库迁移到 ESM，我们正在取得良好的进展，并希望在接下来的几个月内完成这项工作。

---

---
url: /release_notes/d078fwa3/index.md
---
# VSCode 1.83 (2023 年 9 月)
> 主要内容摘抄自 [VSCode 1.83 发行说明](https://code.visualstudio.com/updates/v1_83)，文中“我们”即 VSCode

## [命令面板中的类似命令结果](https://code.visualstudio.com/updates/v1_83#_similar-command-results-in-the-command-palette)

找到您正在寻找的命令可能具有挑战性。仅在 VS Code 中就有 2000 多个命令......有了你最喜欢的扩展，这个数字可以飙升得更高。我们想介绍一种方法来帮助您找到所需的内容，同时仍保持 Command Palette 今天提供的速度。为此，我们在命令面板结果中包含了一个称为“类似命令”的新部分。

我们认为这将真正帮助那些难以记住确切命令名称的人......老实说，这几乎是我们所有人在某个时候的情况。

## [配置文件的图标](https://code.visualstudio.com/updates/v1_83#_icons-for-profiles)

您现在可以将图标与配置文件关联。此图标将显示在“活动栏”中，代替“管理”齿轮图标。如果您有多个配置文件，并且想要快速识别当前处于活动状态的配置文件，这将非常有用。

## [编辑器选项卡高度密度](https://code.visualstudio.com/updates/v1_83#_editor-tab-height-density)

&#x20;设置允许用户将选项卡高度减小到更紧凑的大小。

## [固定在单独行上的编辑器选项卡](https://code.visualstudio.com/updates/v1_83#_pinned-editor-tabs-on-separate-row)

添加了新设置 。激活后，固定的选项卡将显示在其他选项卡上方的单独行中。在选项卡行之间拖动时，编辑器选项卡会自动固定或取消固定。如果未将  设置为 "multiple" 则无效。

## [改进了编辑器操作的溢出行为](https://code.visualstudio.com/updates/v1_83#_improved-overflow-behavior-for-editor-actions)

当编辑器操作的数量超过可用空间时，操作将溢出到“更多操作”菜单中。此逻辑已得到优化，现在排除了一些重要操作，例如“关闭”或“拆分编辑器”。这意味着即使可用空间有限，它们也将始终可见。

## [颜色主题选取器现在显示主题标识符](https://code.visualstudio.com/updates/v1_83#_color-theme-picker-now-shows-theme-identifier)

“颜色主题”选取器现在会显示颜色主题的本地化名称及其旁边的字符串标识符。这样做是为了帮助使用非英语语言包但只知道主题英文名称的用户。

## [为终端菜单做出贡献](https://code.visualstudio.com/updates/v1_83#_contribute-to-terminal-menus)

有两个新菜单可以贡献给终端/上下文和终端/标题/上下文，它们分别向终端上下文菜单和终端选项卡上下文菜单添加条目。用法示例：

```json
{
  "contributes": {
    "menus": {
      "terminal/context": [
        { "command": "terminalTest.sendText" }
      ],
      "terminal/title/context": [
        { "command": "terminalTest.sendText" }
      ]
    }
    }
}
```

---

---
url: /release_notes/dhzn9npg/index.md
---
# VSCode 1.87 (2024 年 2 月)
> 主要内容摘抄自 [VSCode 1.87 发行说明](https://code.visualstudio.com/updates/v1_87)，文中“我们”即 VSCode

## [编辑器粘性滚动](https://code.visualstudio.com/updates/v1_87#_editor-sticky-scroll)

本次迭代我们默认在编辑器中启用粘性滚动。您可以使用设置进行更改 `editor.stickyScroll.enabled` 。

我们还将编辑器粘性小部件中可显示的最大行数从 10 增加到了 20。您可以使用设置来配置最大行数 `editor.stickyScroll.maxLineCount` 。

## [多个游标的内联补全](https://code.visualstudio.com/updates/v1_87#_inline-completions-for-multiple-cursors)

此次迭代我们添加了对多光标内联补全的支持。现在，内联补全可在主光标位置和辅助光标位置进行预览和应用。

## [在多差异编辑器中重构预览](https://code.visualstudio.com/updates/v1_87#_refactor-preview-in-multi-diff-editor)

借助重构预览，您可以查看代码重构将应用的更改。重构预览更改现在显示在多差异编辑器中，便于一目了然地查看所有更改并将其与之前的版本进行比较。

## [跟踪命令持续时间](https://code.visualstudio.com/updates/v1_87#_command-duration-tracked)

现在可跟踪终端持续时间，并且在启用 shell 集成时，命令悬停中会显示详细信息

## [新的放大、缩小和重置命令](https://code.visualstudio.com/updates/v1_87#_new-commands-to-zoom-in-out-and-reset)

有新的命令可以放大、缩小和重置终端字体大小。默认情况下，这些命令不受约束，但您可以将它们绑定到您喜欢的键绑定。

* 终端：增加字体大小( workbench.action.terminal.fontZoomIn)
* 程序端：减小字体大小( workbench.action.terminal.fontZoomOut)
* 终端：重置字体大小( workbench.action.terminal.fontZoomReset)

## [在窗口标题中包含存储库或分支名称](https://code.visualstudio.com/updates/v1_87#_include-repository-or-branch-name-in-the-window-title)

用户可以使用window.title设置自定义窗口标题。 这次迭代，我们添加了两个可与此设置一起使用的新变量：`${activeRepositoryName}` 和 `${activeRepositoryBranchName}` 。 这些变量分别替换为活动存储库和活动分支的名称。

## [关闭所有未修改的编辑器命令](https://code.visualstudio.com/updates/v1_87#_close-all-unmodified-editors-command)

为了帮助管理编辑器，我们在命令面板中添加了 `Close All Unmodified Editors` 命令，该命令将关闭所有包含未修改文件的编辑器。该命令不会关闭包含未保存更改的编辑器。

## [为本地运行的 JUPYTER 服务器提供语言服务器支持](https://code.visualstudio.com/updates/v1_87#_language-server-support-for-locally-running-jupyter-servers)

当连接到本地 Jupyter 服务器时，Jupyter扩展程序以前会将这些 Jupyter 服务器视为远程服务器。因此，Pylance扩展程序无法检测到已安装的软件包。

此次迭代中，Jupyter扩展会检测连接的 Jupyter 服务器是本地的还是远程的。这使得Pylance扩展能够根据安装的软件包（在本地 Python 环境中）提供更丰富的语言功能。

## [FindFiles2 API](https://code.visualstudio.com/updates/v1_87#_findfiles2-api)

我们添加了一个新的建议扩展 API，它是现有workspace.FindFilesAPI 的改进版本。新workspace.FindFiles2API 引入了新选项，允许工作区文件搜索：

* 尊重files.exclude与search.exclude设置
* 尊重忽略文件
* 执行模糊搜索
* 跟踪符号链接

[您可以在此处](https://translate.google.com/website?sl=auto\&tl=zh-CN\&hl=zh-CN\&u=https://github.com/microsoft/vscode/blob/4e2aa982224429f161423cbdded9587e39766782/src/vscode-dts/vscode.proposed.findFiles2.d.ts)查看新的 API 。

请注意，这是一个暂定名称，将来 `FindFiles2` 可能会将此功能作为 `FindFiles` 的替代重载提供。

---

---
url: /release_notes/e5yq7hbi/index.md
---
# VSCode 1.71
> 主要内容摘抄自 [VSCode 1.71 发行说明](https://code.visualstudio.com/updates/v1_71)，文中“我们”即 VSCode

## [合并编辑器改进](https://code.visualstudio.com/updates/v1_71#_merge-editor-improvements)

## [FFmpeg 编解码器支持](https://code.visualstudio.com/updates/v1_71#_ffmpeg-codecs-support)

作为 VS Code 的一部分提供的 FFmpeg 共享库以前仅支持 FLAC 编解码器。在此版本中，库已更新为支持以下编解码器和容器列表。这将允许从笔记本播放更多音频和视频文件，或者通过扩展将音频和视频嵌入到 Web 视图中来播放。

* Vorbis
* Flac
* H.264
* VP8
* WAV
* MP3
* Ogg

## [编辑器粘性滚动](https://code.visualstudio.com/updates/v1_71#_sticky-scroll)

## [新的代码操作控件](https://code.visualstudio.com/updates/v1_71#_new-code-action-control)

## [终端流畅滚动](https://code.visualstudio.com/updates/v1_71#_smooth-scrolling)

该终端现在支持平滑滚动，这将在短时间内动画滚动，以帮助您在滚动后查看您的位置，类似于编辑器和列表。要启用平滑滚动设置：

```json
"terminal.integrated.smoothScrolling": true
```

## [Live Preview](https://code.visualstudio.com/updates/v1_71#_live-preview)

实时预览扩展现在正式支持多根工作区！尽管从技术上讲，用户以前可以在多根工作区中使用实时预览，但现在有一个更清晰的实现支持它。

现在，实时预览扩展会为多根工作区中的每个根启动一个新服务器;因此，在预览多根工作区时，相对于项目根的链接（以 / 开头的链接）将正常工作。

安装 [Live Preview](http://aka.ms/live-preview) 扩展程序并立即试用！📡✨🔎

## [TerminalExitStatus.reason](https://code.visualstudio.com/updates/v1_71#_terminalexitstatusreason)

扩展作者现在可以更好地了解终端通过新的 TerminalExitReason API 退出的原因。

```ts
export enum TerminalExitReason {
  Unknown = 0,
  Shutdown = 1,
  Process = 2,
  User = 3,
  Extension = 4
}
```

## [Electron 19 更新](https://code.visualstudio.com/updates/v1_71#_electron-19-update)

在这个里程碑中，我们完成了将 Electron 19 捆绑到 VS Code 桌面的探索。此更新附带 Chromium 102.0.5005.167 和 Node.js 16.14.2

---

---
url: /release_notes/fw1epg2w/index.md
---
# VSCode 1.101 (2025 年 5 月)
> 主要内容摘抄自 [VSCode 1.101 发行说明](https://vscode.js.cn/updates/v1_101)，文中“我们”即 VSCode

## [边输入边查找](https://vscode.js.cn/updates/v1_101#_find-as-you-type)

设置：&#x20;
边输入边查找一直是查找控件的默认行为，但现在您可以控制是否保持这种方式或禁用它，以便它只在按 Enter 后执行搜索。

## [未发布的扩展程序警告](https://vscode.js.cn/updates/v1_101#_unpublished-extension-warning)

当已安装的扩展程序不再在 Marketplace 中可用时，现在会显示警告指示器，帮助您识别可能已取消发布或删除的问题扩展程序。

---

---
url: /release_notes/fzpsrc67/index.md
---
> 主要内容摘抄自 [VSCode 1.89 发行说明](https://code.visualstudio.com/updates/v1_89)，文中“我们”即 VSCode

## [本地工作区扩展](https://code.visualstudio.com/updates/v1_89#_local-workspace-extensions)

本地工作区扩展首次在 VS Code 1.88 版本中推出，现已（v1.89）普遍可用。您现在可以直接将扩展包含在您的工作区中，并仅为该工作区安装它。此功能旨在满足您特定的工作区需求，并提供更加量身定制的开发体验。

要使用此功能，您需要将扩展放在您的工作区的.vscode/extensions 文件夹中。然后，VS Code 会在扩展视图的工作区推荐部分显示此扩展，用户可以从那里安装它。VS Code 仅为该工作区安装此扩展。本地工作区扩展需要用户信任工作区，然后才能安装和运行此扩展。

请注意，您应该将解压后的扩展包含在.vscode/extensions 文件夹中，而不是 VSIX 文件。您也可以只包含扩展的源代码，并将其作为工作区设置的一部分构建。

这真是令人兴奋的更新，[汐洛插件现已适配该特性](https://ld246.com/forward?goto=https%3A%2F%2Fgithub.com%2FHi-Windom%2FSillot%2Fissues%2F681)

## [快速打开中的自定义编辑器标签](https://code.visualstudio.com/updates/v1_89#_custom-editor-labels-in-quick-open)

上个月，我们推出了[自定义标签功能](https://ld246.com/forward?goto=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fgetstarted%2Fuserinterface%23_customize-tab-labels)，让您可以个性化编辑器标签。该功能旨在帮助您更轻松地区分具有相同名称的文件的标签，例如 index.tsx 文件。

在此基础上，我们已将自定义标签的使用扩展到快速打开功能 (Ctrl+P)。现在，您可以使用您创建的自定义标签搜索文件，使文件导航更加直观。

这个更新在我看来有点乏善可陈，毕竟更新前也可以轻易区分同名的标签，不过汐洛还是记录在案了。

## [切换分支时保存/恢复打开的编辑器](https://code.visualstudio.com/updates/v1_89#_saverestore-open-editors-when-switching-branches)

这个里程碑，我们解决了一个长期存在的功能请求，即在源代码控制分支之间切换时保存和恢复编辑器。 使用 `"scm.workingSets.enabled": true` 设置以启用此功能。

当首次切换到一个分支时，要控制打开的编辑器，可以使用 scm.workingSets.default 设置。您可以选择没有打开的编辑器（空），或者使用当前已打开的编辑器（current， 默认值）。

## [禁用大型笔记本的备份](https://code.visualstudio.com/updates/v1_89#_disabled-backups-for-large-notebooks)

现在已经禁用了大型笔记本文件的周期性文件备份，以减少写入磁盘的时间。可以通过设置 `notebook.backup.sizeLimit` 来调整限制。我们还在尝试一个选项 `"notebook.experimental.remoteSave": true` ，可以在保存笔记本文件时避免阻塞渲染器，以便自动保存不会带来性能损失。

## [修复大纲/粘性滚动性能退化问题](https://code.visualstudio.com/updates/v1_89#_fix-for-outlinesticky-scroll-performance-regressions)

在过去几个月里，我们收到了关于笔记本编辑器性能退化的反馈。\*\*这些退化很难准确定位，也不容易复现。感谢社区不断提供日志和反馈，我们发现这些退化来自大纲和粘滚动功能，因为我们对它们添加了新功能。这些问题已在此版本中修复。

我们感谢社区的反馈和耐心，我们会继续改进笔记本编辑器的性能。如果您继续遇到性能问题，请毫不犹豫地在 VS Code 仓库中提交新问题。

## [快速搜索](https://code.visualstudio.com/updates/v1_89#_quick-search)

快速搜索使您能够在工作区文件中快速执行文本搜索（使用 % 百分号前缀）。快速搜索不再是实验性的，所以试试吧！✨🔍

请注意，所有快速搜索命令和设置中不再包含“实验性”关键词在其标识符中。例如，命令 ID `workbench.action.experimental.quickTextSearch` 变为了 `workbench.action.quickTextSearch`。**如果您的设置或按键绑定使用了这些旧的 ID，则这可能是相关的。**

## [搜索树递归展开](https://code.visualstudio.com/updates/v1_89#_search-tree-recursive-expansion)

**我们新增了一个上下文菜单选项，可以让您在搜索树中递归地打开所选的树节点。**

## [⚠️ 画布渲染器的弃用](https://code.visualstudio.com/updates/v1_89#_-deprecation-of-the-canvas-renderer)

该终端设备具有三种不同的渲染器：DOM 渲染器、WebGL 渲染器和画布渲染器。我们一直想要移除画布渲染器，但由于 DOM 渲染器性能不佳以及 WebKit 未实现 webgl2，我们被阻止了。**这两个问题现在都已解决！**

在这个版本中，我们从备用链中移除了画布渲染器，因此只有在将 `terminal.integrated.gpuAcceleration` 设置显式设置为“canvas”时才启用它。\*\*我们计划在下一个版本中彻底移除画布渲染器。**如果当 `terminal.integrated.gpuAcceleration` 设置为“on”或“off”时出现问题，请告诉我们。**

## [Markdown 路径补全中的图像预览](https://code.visualstudio.com/updates/v1_89#_image-previews-in-markdown-path-completions)

VS Code 内置的 Markdown 工具为 Markdown 中的链接和图片提供路径补全。在完成对图像或视频文件的路径时，我们现在在完成详情中直接显示一个小预览。**这可以帮助您更轻松地找到所需的图像或视频。**

## [悬停以预览 Markdown 中的图像和视频](https://code.visualstudio.com/updates/v1_89#_hover-to-preview-images-and-videos-in-markdown)

想要在不打开完整的 Markdown 预览的情况下快速预览图像或视频吗？现在，您可以将鼠标悬停在图像或视频路径上，以查看其小预览。

## [改进的 Markdown 标题重命名](https://code.visualstudio.com/updates/v1_89#_improved-markdown-header-renaming)

你知道吗，VS Code 内置的 Markdown 支持允许您使用 F2 重命名标题？这很有用，因为它还会自动更新所有链接到该标题的链接。**在这个迭代中，我们改进了在 Markdown 文件中存在重复标题的重命名处理。**

**考虑 Markdown 文件：**

```md
# Readme

- [Example 1](#example)
- [Example 2](#example-1)

## Example
...

## Example
...



```

两个示例标题具有相同的文本，但可以通过使用唯一的 ID（`＃example ` 和 `＃example-1`）分别链接到每个标题。以前，如果将第一个示例标题重命名为第一个示例，`＃example` 链接将正确更改为 `＃first-example`，但 `＃example-1` 链接将不会更改。**但是，在重命名后，`＃example-1` 不再是有效的链接，因为不再存在重复的示例标题。**

我们现在正确处理这种情况。例如，如果您将文档中的第一个 `## Example` 标题重命名为 `## First Example`，则新文档将是：

```md
# Readme
- [Example 1](#first-example)
- [Example 2](#example)

## First Example
...

## Example
...

```

请注意，现在两个链接都已自动更新，以确保它们仍然有效！

## [粘贴时自动更新的 Markdown 链接](https://code.visualstudio.com/updates/v1_89#_automatic-markdown-link-updates-on-paste)

比方说，你正在撰写一些 Markdown 文档，然后意识到文档中的某一部分实际上应该放在另一个地方。于是，你将它复制并粘贴到另一个文件中。一切都很好，对吧？但是，如果复制的文本中包含任何相对路径链接、引用链接或图像，那么这些链接很可能会失效，你将不得不手动修复它们。这可能会很麻烦，但幸运的是，新的“粘贴后更新链接”功能来帮忙啦！

要启用此功能，只需将 `markdown.experimental.updateLinksOnPaste` 设置为 true。启用后，当您在当前编辑器的 Markdown 文件之间复制和粘贴文本时，VS Code 会自动修复所有相对路径链接、引用链接以及所有具有相对路径的图片/视频。

**粘贴后，如果您意识到您实际上想要插入您复制的确切文本，您可以使用粘贴控制切换回正常的复制/粘贴行为。**

## [Python 新的自动缩进设置](https://code.visualstudio.com/updates/v1_89#_new-auto-indentation-setting)

以前，Pylance 的自动缩进行为是通过 `editor.formatOnType` 设置来控制的，如果你想禁用自动缩进但启用其他支持工具的格式化，这可能会有问题。为了解决这个问题，Pylance 有自己的设置来控制其自动缩进行为：`python.analysis.autoIndent`，默认情况下是启用的。

---

---
url: /release_notes/g3hq382l/index.md
---
# VSCode 1.104 (2025 年 8 月)
没有值得注意的更新。

---

---
url: /release_notes/g9ltsn2t/index.md
---
# VSCode 1.98 (2025 年 2 月)
没有值得注意的更新。

---

---
url: /release_notes/hwetd2gp/index.md
---
# 94to114
Chromium 94 功能冻结于2021年7月29日，已经不满足新彖乄要求。
2024年7月15日，汐洛彖夲肜矩阵v0.35将要求提升至 114（2023年4月11日功能冻结）。

受此影响，VSCode 要求提升至 [1.82 (2023 年 8 月)](../VSCode/1_82.md)

## 新增支持

### CSS Initial Letter

\*\[CSS Initial Letter]: CSS 首字母

> 由不支持变更为部分支持（ 110 开始）

部分支持是指仅支持 initial-letter 属性（不是 initial-letter-align 或 initial-letter-wrap ）

### Small, Large, and Dynamic viewport units

\*\[Small, Large, and Dynamic viewport units]: 小型、大型和动态视口单元

> 由不支持变更为完全支持（ 108 开始）

### Media Queries: Range Syntax

\*\[Media Queries: Range Syntax]: 媒体查询：范围语法

> 由不支持变更为完全支持（ 104 开始）

语法改进，使使用具有“范围”类型（如宽度或高度）的功能的媒体查询不那么冗长。可以与普通的数学比较运算符一起使用。
例如： @media (100px <= width <= 1900px) 等价于 @media (min-width: 100px) and (max-width: 1900px)

### LCH and Lab color values

\*\[LCH and Lab color values]: LCH 和 Lab 颜色值

> 由不支持变更为完全支持（ 111 开始）

lch() 和 lab() 颜色函数基于CIE LAB色彩空间，以与人类感知非常接近的方式表示颜色，并提供比通常的RGB色彩空间更广泛的颜色范围。

### :has() CSS relational pseudo-class

\*\[:has() CSS relational pseudo-class]: :has() CSS 关系伪类

> 由不支持变更为完全支持（ 105 开始）

> 非常实用的特性，不过使用时注意尽可能缩小范围以提升性能。

选择包含特定内容的元素。例如， a:has(img) 选择包含 `<img>` 子元素的所有 `<a>` 元素。

### CSS font-palette + COLR/CPAL(v1) Font Formats

\*\[CSS font-palette + COLR/CPAL(v1) Font Formats]: CSS 字体调色板 + COLR/CPAL（v1）字体格式

> 由不支持变更为完全支持（ COLR/CPAL（v1）字体格式从 98 开始；CSS 字体调色板从 101 开始）

参考：https://www.zhangxinxu.com/wordpress/2022/07/css-font-palette/

### CSS Container Query Units

\*\[CSS Container Query Units]: CSS 容器查询单元

> 由不支持变更为完全支持（ 105 开始）

容器查询单元指定相对于查询容器维度的长度。单位包括：cqw, cqh, cqi, cqb, cqmin, cqmax.

### CSS Container Queries (Size)

\*\[CSS Container Queries (Size)]: CSS 容器查询（大小）

> 由不支持变更为完全支持（ 106 开始）

105 在多列布局中组合大小容器查询和表布局不起作用

### CSS Container Style Queries

\*\[CSS Container Style Queries]: CSS 容器样式查询

> 由不支持变更为部分支持（ 111 开始）

部分支持是指仅在 style() 查询中使用 CSS 自定义属性值

### CSS color() function

\*\[CSS color() function]: CSS color 函数

> 由不支持变更为完全支持（ 111 开始）

CSS color() 函数允许浏览器显示任何颜色空间中的颜色，例如 P3 颜色空间，它可以显示默认 sRGB 颜色空间之外的颜色。

### CSS Cascade Layers

\*\[CSS Cascade Layers]: CSS 级联层

> 由不支持变更为完全支持（ 99 开始）

`@layer`

### Passkeys

\*\[Passkeys]: 通行密钥

> 由不支持变更为完全支持（ 108 开始）

通行密钥，也称为多设备 FIDO 凭据，为用户提供了更易于使用且更安全的密码替代方案。FIDO 是商业认证，对汐洛来说没有用处。

### MathML

> 由不支持变更为完全支持（ 109 开始）

允许在网页上编写数学公式和符号的特殊标签。基于 Chromium 的浏览器特别支持 [MathML Core](https://www.w3.org/TR/mathml-core/)。虽然与其他 MathML 实现有很大的支持重叠，但也存在一些差异（[详见](https://groups.google.com/a/chromium.org/g/blink-dev/c/n4zf_3FWmAA/m/oait3tsMAQAJ)）。

### CSS Nesting

\*\[CSS Nesting]: CSS 嵌套

> 由不支持变更为部分支持（ 112 开始）

> 112-119 不允许嵌套类型（元素）选择器而不以符号开头，如 & 嵌套选择器。

CSS 嵌套提供了将一个样式规则嵌套到另一个样式规则中的能力，子规则的选择器相对于父规则的选择器。类似的行为以前需要 CSS 预处理器。

### View Transitions API (single-document)

\*\[View Transitions API (single-document)]: View Transitions API（单文档）

> 由不支持变更为完全支持（ 111 开始）

参考：https://juejin.cn/post/7255675484938256441

### WebTransport

> 由不支持变更为完全支持（ 97 开始）

> 已知问题：（1） Chromium 浏览器存在 WebTransport 连接过度限制的问题，无法通过代码缓解。
> （2） Chromium 浏览器存在一个问题，即关闭流的写入器端将关闭，而不会确保实际发送所有先前发送的数据。

使用 HTTP3 从服务器发送和接收数据的协议框架。类似于 WebSockets，但支持多流、单向流、无序交付以及可靠和不可靠的传输。

### WebGPU

> 由不支持变更为完全支持（ 113 开始）

> 默认情况下，在 Linux 上未启用。

使用硬件加速进行复杂渲染和计算的 API。用例包括要求苛刻的 3D 游戏和加速科学计算。旨在取代 WebGL。

### CSS text-wrap: balance

\*\[CSS text-wrap: balance]: CSS 文本换行：平衡

> 由不支持变更为部分支持（ 114 开始）

允许多行文本以每行大致相同的宽度中断行，通常用于使标题更具可读性和视觉吸引力。部分支持是指仅支持 text-wrap： balance，不支持 text-wrap-style： balance。

### HEVC/H.265 video format

> 由不支持变更为部分支持（ 107 开始）

浏览器很难普遍支持 HEVC，因为它既复杂又昂贵。HEVC 与 AV1 竞争，AV1 具有相似的压缩质量并提供免费许可证。
支持 Android （>= 5.0） 上的所有设备，支持在 Windows 上支持硬件的设备 （>= Windows 8），以及在 Linux 和 ChromeOS 上支持由 VAAPI 提供支持的硬件设备。
如果 Edge >= 107，则支持 Android （>= 5.0） 上的所有设备，适用于在 Windows （>= Windows 10 1709） 上支持硬件的设备，当安装了 Microsoft Store 中的 HEVC 视频扩展时。

## 修改支持

### text-emphasis styling

\*\[text-emphasis styling]: 文本强调样式

> 由部分支持变更为完全支持（ 99 开始）

> 已知问题：Android 版 Chrome 偶尔会出现正确渲染强调字形的问题。

部分支持是指对 -webkit-text-emphasis-position 的错误支持。这些浏览器支持 and under 作为值，但不支持 over 规范要求的 added left 和 right values。

### CSS image-set

\*\[CSS image-set]: CSS 图像集

> 由部分支持变更为完全支持（ 114 开始）

112 版本前支持非常有限。仅 url() 被接受为图像，并且仅 x 被接受为分辨率。

113 版本不支持 calc() 用于分辨率。

### Declarative Shadow DOM

\*\[Declarative Shadow DOM]: 声明式影子 DOM

> 由部分支持变更为完全支持（ 111 开始）

部分支持是指使用较旧的非标准属性，而不是标准化属性 shadowroot shadowrootmode

### CSS page-break properties

\*\[CSS page-break properties]: CSS 分页符属性

> 由部分支持变更为完全支持（ 108 开始）

> 并非所有移动浏览器都提供打印支持，即列出的支持基于浏览器引擎功能。

> 支持 CSS 2.1 规范中的 page-break-\* 别名，但不支持最新规范中的 break-\* 属性。

部分支持是由于不支持 avoid page-break-before & page-break-after （仅 page-break-inside ）。

## 移除支持

### CSS overflow: overlay

> 已弃用（ 114 开始）

> 该 overlay 值可识别，但行为与“auto”相同。

overflow CSS 属性的 overlay 值是一个非标准值，用于使滚动条显示在内容顶部而不是占用空间。此值已弃用，相关功能将标准化为 scrollbar-gutter 属性。

## 其他

### popover 属性支持

见 https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global\_attributes/popover

---

---
url: /release_notes/ievx161f/index.md
---
# VSCode 1.69
> 主要内容摘抄自 [VSCode 1.69 发行说明](https://code.visualstudio.com/updates/v1_69)，文中“我们”即 VSCode

## [3 路合并编辑器](https://code.visualstudio.com/updates/v1_69#_3-way-merge-editor)

在此版本中，我们继续开发 3 向合并编辑器。可以通过将  设置为 true 来启用此功能，并将在未来的版本中默认启用此功能。

合并编辑器允许您快速解决 Git 合并冲突。启用后，可以通过单击“源代码管理”视图中的冲突文件来打开合并编辑器。复选框可用于接受和合并“他们的”或“您的”中的更改。

合并编辑器中提供了所有语言功能（包括诊断、断点和测试），因此您可以立即获得有关合并结果中任何问题的反馈。

合并编辑器支持单词级合并——只要更改不相交，双方都可以应用。如果插入顺序很重要，可以交换。在任何时候，冲突也可以手动解决。

## [小地图上下文菜单](https://code.visualstudio.com/updates/v1_69#_minimap-context-menu)

VS Code 小地图在编辑器一侧显示源代码文件的高级轮廓。您已经能够通过“查看：切换小地图”命令切换小地图的可见性，或使用“编辑器 > 小地图：启用”（`editor.minimap.enabled`） 设置完全禁用小地图。在此版本中，现在有一个上下文菜单，可以轻松显示或隐藏小地图。

您还可以使用大小 （`editor.minimap.size`）、比例 （`editor.minimap.scale`） 和滑块 （`editor.minimap.showSlider`） 设置来调整外观。如果小地图处于隐藏状态，您仍可以通过右键单击侧面装订线来显示上下文菜单。

## [使用编辑器创作提交消息](https://code.visualstudio.com/updates/v1_69#_author-commit-message-using-an-editor)

在这个里程碑上，现在，只要提交输入框中未提供任何消息，您就可以使用全文编辑器来编写提交消息。要使用此新流程，请单击“提交”按钮，而不提供提交消息。

现在，您可以在编辑器中编写提交消息。要接受提交消息并完成提交操作，请关闭编辑器选项卡或在编辑器工具栏中选择“接受提交消息”按钮。要取消提交操作，您可以清除文本编辑器的内容并关闭编辑器选项卡，或者在编辑器工具栏中选择“放弃提交消息”按钮。

您可以通过切换  设置来禁用此新流程，并回退到使用快速输入控件的上一个体验。更改设置后，必须重新启动 VS Code 才能使更改生效。

要对在集成终端中执行的 `git commit` 命令使用相同的流程，请启用  设置。启用该设置后，您将必须重新启动终端会话。

## [支持 Markdown 中的尖括号链接](https://code.visualstudio.com/updates/v1_69#_support-for-angle-bracket-links-in-markdown)

Markdown 允许您使用尖括号来编写包含空格或其他特殊字符的链接目标：

```md
[Some link](<path to file with spaces.md>)
```

在此迭代中，我们改进了对尖括号链接的支持，以便它们在编辑器中正确突出显示和单击。

## [HTML 最终新行格式化程序设置更改](https://code.visualstudio.com/updates/v1_69#_html-final-new-line-formatter-setting-change)

设置 `html.format.endWithNewline` 已被删除，取而代之的是 `files.insertFinalNewline` 。

`files.insertFinalNewline` 适用于所有编程语言。如果希望每种语言进行不同的设置，可以使用语言范围：

```json
{
  "[html]": {
    "files.insertFinalNewline": true
  }
}
```

## [可扩展的笔记本渲染器](https://code.visualstudio.com/updates/v1_69#_extensible-notebook-renderers)

笔记本渲染器允许扩展自定义单元格和输出在笔记本中的呈现方式。在此迭代中，我们扩展了笔记本渲染器 API，以允许渲染器增强另一个渲染器，包括 VS Code 中的一些内置渲染器。这允许扩展向笔记本渲染添加新功能，而无需重新实现完整的渲染器。它还提供了更好的用户体验，因为用户不必在新的渲染器之间切换即可查看正确渲染的内容。

[Notebook 扩展 Markdown 呈现器示例](https://github.com/microsoft/vscode-extension-samples/tree/main/notebook-extend-markdown-renderer-sample)演示扩展如何使用表情符号支持扩展 VS Code 的内置 Markdown 呈现器。让我们快速浏览一下关键部分！

可扩展笔记本渲染器的 API 是有意松散定义的。首先，我们的扩展需要贡献一个新的笔记本渲染器。因为我们要扩展现有的渲染器，所以我们在这里使用 entrypoint 字段来指定要扩展的渲染器的 ID（在本例中为 VS Code 的内置 vscode.markdown-it-renderer）以及要加载的渲染器脚本的路径：

```json
"notebookRenderer": [
    {
        "id": "sample.markdown-it.emoji-extension",
        "displayName": "Markdown it Emoji renderer",
        "entrypoint": {
            "extends": "vscode.markdown-it-renderer",
            "path": "./out/emoji.js"
        }
    }
]
```

现在，只要激活 vscode.markdown-it-renderer ，此渲染器就会被激活。

现在，为了扩展 vscode.markdown-it-renderer，我们的渲染器可以在基础渲染器上调用一个方法。此方法特定于基本呈现器。在本例中，我们首先使用 getRenderer 获取基础渲染器，然后在其上调用 extendMarkdownIt 以增强它用于渲染的 Markdown-It 实例：

```ts
import type * as MarkdownIt from 'markdown-it';
import type { RendererContext } from 'vscode-notebook-renderer';

interface MarkdownItRenderer {
    extendMarkdownIt(fn: (md: MarkdownIt) => void): void;
}

export async function activate(ctx: RendererContext<void>) {
    // Acquire the base renderer
    const markdownItRenderer = await ctx.getRenderer('vscode.markdown-it-renderer') as MarkdownItRenderer | undefined;
    if (!markdownItRenderer) {
        throw new Error(`Could not load 'vscode.markdown-it-renderer'`);
    }

    // Load our Markdown-It extension
    const emoji = require('markdown-it-emoji');

    // Call the base renderer's extension method (extendMarkdownIt) to augment
    // the Markdown-It with emoji support.
    markdownItRenderer.extendMarkdownIt((md: MarkdownIt) => {
        return md.use(emoji, {});
    });
}
```

这里要注意的关键部分是 extendMarkdown 它只是基础渲染器返回的一个方法。其他可扩展渲染器可以轻松返回自己的扩展点。

请查看 [Notebook 扩展 Markdown 渲染器示例](https://github.com/microsoft/vscode-extension-samples/tree/main/notebook-extend-markdown-renderer-sample)，获取扩展 VS Code 的内置 Markdown-It 渲染器的完整示例。

## [粘贴编辑提供程序](https://code.visualstudio.com/updates/v1_69#_paste-edit-provider)

我们更新了 documentPaste API 提案，使其更易于正确实现，特别是在使用多个游标时。

提醒一下，此 API 允许扩展挂钩到文本编辑器内的复制和粘贴。扩展可以使用它来修改粘贴时插入的文本。[文档粘贴扩展示例](https://github.com/microsoft/vscode-extension-samples/tree/main/document-paste)显示了运行中的更新的 API：

```ts
/**
 * Provider that maintains a count of the number of times it has copied text.
 */
class CopyCountPasteEditProvider implements vscode.DocumentPasteEditProvider {
  private readonly countMimeTypes = 'application/vnd.code.copydemo-copy-count';

  private count = 0;

  prepareDocumentPaste?(
    _document: vscode.TextDocument,
    _ranges: readonly vscode.Range[],
    dataTransfer: vscode.DataTransfer,
    _token: vscode.CancellationToken
  ): void | Thenable<void> {
    dataTransfer.set(this.countMimeTypes, new vscode.DataTransferItem(this.count++));
    dataTransfer.set('text/plain', new vscode.DataTransferItem(this.count++));
  }

  async provideDocumentPasteEdits(
    _document: vscode.TextDocument,
    _ranges: readonly vscode.Range[],
    dataTransfer: vscode.DataTransfer,
    _token: vscode.CancellationToken
  ): Promise<vscode.DocumentPasteEdit | undefined> {
    const countDataTransferItem = dataTransfer.get(this.countMimeTypes);
    if (!countDataTransferItem) {
      return undefined;
    }

    const textDataTransferItem = dataTransfer.get('text') ?? dataTransfer.get('text/plain');
    if (!textDataTransferItem) {
      return undefined;
    }

    const count = await countDataTransferItem.asString();
    const text = await textDataTransferItem.asString();

    // Build a snippet to insert
    const snippet = new vscode.SnippetString();
    snippet.appendText(`(copy #${count}) ${text}`);

    return { insertText: snippet };
  }
}

export function activate(context: vscode.ExtensionContext) {
  // Enable our provider in plaintext files
  const selector: vscode.DocumentSelector = { language: 'plaintext' };

  // Register our provider
  context.subscriptions.push(
    vscode.languages.registerDocumentPasteEditProvider(
      selector,
      new CopyCountPasteEditProvider(),
      {
        pasteMimeTypes: ['text/plain']
      }
    )
  );
}
```

## [Electron 18 更新](https://code.visualstudio.com/updates/v1_69#_electron-18-update)

在这个里程碑中，我们完成了将 Electron 18 捆绑到 VS Code 桌面的探索。此更新附带 Chromium 100.0.4896.160 和 Node.js 16.13.2

---

---
url: /release_notes/jqldo0c2/index.md
---
# VSCode 1.77
> 主要内容摘抄自 [VSCode 1.77 发行说明](https://code.visualstudio.com/updates/v1_77)，文中“我们”即 VSCode

## [从编辑器装订线复制 GitHub 深层链接](https://code.visualstudio.com/updates/v1_77#_copy-github-deep-links-from-editor-gutter)

现在，在 GitHub 仓库中工作时，您可以从编辑器装订线复制编辑器行或范围的深层链接。

在 VS Code Desktop 中，为了能够从编辑器装订线创建 GitHub 永久链接和 HEAD 链接，您需要安装 [GitHub Pull Requests and Issues](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github) 扩展。在 vscode.dev 中，GitHub 仓库的深层链接开箱即用。

\==在非主分支上的永久链接可能404=={.warning}

## [按文件内容推荐扩展名](https://code.visualstudio.com/updates/v1_77#_recommend-extensions-by-file-content)

VS Code 现在可以根据文件内容推荐扩展。例如，如果打开具有笔记本单元格语法的 Python 文件，VS Code 建议使用 Jupyter 扩展来适当地呈现和运行这些单元格。

## [改进了终端选项卡悬停](https://code.visualstudio.com/updates/v1_77#_improved-tab-hover)

终端选项卡悬停现在显示 shell 的进程 ID、完整的命令行以及改进的扩展环境变量贡献视图。

---

---
url: /release_notes/k2qs0ylw/index.md
---
# VSCode 1.66
import myImage3 from "@assets/shots/2024-08-09--vscode1.66\_\_inputboxseverity.png"

> 主要内容摘抄自 [VSCode 1.66 发行说明](https://code.visualstudio.com/updates/v1_66)，文中“我们”即 VSCode

## [当地历史](https://code.visualstudio.com/updates/v1_66#_local-history)

现在，文件的本地历史记录可在时间轴视图中使用。根据配置的设置，每次保存编辑器时，都会向列表中添加一个新条目。

每个本地历史记录条目包含创建条目时文件的全部内容，并且在某些情况下，可以提供更多的语义信息（例如，指示重构）。

从一个条目中，您可以：

* 将更改与本地文件或以前的条目进行比较。
* 回滚操作。
* 删除或重命名条目。

有新的全局命令可用于本地历史记录：

* `workbench.action.localHistory.create` - 用自定义名称为活动文件创建一个新的历史记录条目。
* `workbench.action.localHistory.deleteAll` - 删除所有文件中的所有历史记录条目。
* `workbench.action.localHistory.restoreViaPicker` - 查找要跨所有文件恢复的历史记录条目。

这些命令没有默认的键绑定，但您可以添加自己的键盘快捷键。

还有一些新的设置可以处理本地历史：

* &#x20;\- 启用或禁用本地历史记录（默认值：true）。
* &#x20;\- 创建本地历史记录条目时的文件大小限制（默认值：256 KB）。
* &#x20;\- 每个文件的本地历史记录条目限制（默认值：50）。
* &#x20;\- 用于从本地历史中排除某些文件的Glob模式。
* &#x20;\- 将进一步更改添加到本地文件历史记录中的最后一个条目的时间间隔（以秒为单位）（默认值为10秒）。

注意：本地历史记录条目存储在不同的位置，具体取决于您对VS Code的使用。当打开本地文件时，这些条目将保存在本地用户数据文件夹中，当打开远程文件时，它们将存储在远程用户数据文件夹中。当没有可用的文件系统时（例如，在某些情况下，当使用VS Code for Web时），条目存储到IndexedDB中。

## [设置编辑器](https://code.visualstudio.com/updates/v1_66#_settings-editor)

### 语言过滤器

用户现在可以在设置编辑器搜索框中键入 `@lang: languageId` ，以查看和编辑可以为ID为`languageId`的语言配置的所有设置。这样，用户可以查看特定于语言的设置，也称为语言覆盖。

请注意，这些覆盖将保持配置状态，直到通过单击齿轮图标并重置设置来明确重置。

### 工作区和文件夹设置保留

设置编辑器中的工作区和文件夹设置现在将保留，直到用户手动重置。此更改有助于用户明确指定等于设置的默认值但不同于用户设置值的工作区设置值的情况。以前，用户必须打开工作区设置JSON文件来设置此值。

在编辑器选项卡下方，在设置编辑器工作区选项卡中设置选项卡大小，并自动添加到工作区的 `settings.json` 文件中。

## [主要通知按钮](https://code.visualstudio.com/updates/v1_66#_primary-notification-buttons)

通知的第一个按钮现在以原色显示，以区别于其他按钮。它遵循与对话框相同的模式。

## [默认二进制编辑器](https://code.visualstudio.com/updates/v1_66#_default-binary-editor)

一个新的设置， ，允许您绕过二进制文件警告，并在检测到二进制文件时自动打开您选择的编辑器类型。您可以从设置编辑器中的一个按钮或通过settings.json中的智能感知来选择默认的二进制编辑器ID。

## [更流畅的身份验证体验](https://code.visualstudio.com/updates/v1_66#_smoother-authentication-experiences)

您可能会注意到GitHub和Microsoft的身份验证流程更加顺畅。

* 对于GitHub身份验证，我们已经删除了初始的继续页面，因此您的登录体验需要少一步。
* 对于Microsoft身份验证，如果您已经使用Microsoft的设置同步或其他扩展登录，我们会尽量减少您从VS Code中被发送出去登录的次数。

## [从CLI同时安装预发行版和普通扩展](https://code.visualstudio.com/updates/v1_66#_install-prerelease-and-normal-extensions-together-from-cli)

VS Code现在支持从命令行同时安装预发行版和普通扩展。例如，以下命令行指令将安装GitHub.vscode-pull-request-github扩展的预发布版本和GitHub.remotehub扩展的发布版本：

```bash
code --install-extension GitHub.vscode-pull-request-github@prerelease --install-extension GitHub.remotehub
```

## [改进的平台特定扩展更新](https://code.visualstudio.com/updates/v1_66#_improved-platform-specific-extension-updates)

VS Code现在支持将特定于平台的扩展更新为更具体的目标平台版本。例如，如果您使用的是Windows 64位，并且已经安装了Windows 32位的C/C++扩展，并且Marketplace具有与Windows 64位相同版本的扩展，则VS Code将自动将扩展更新为64位版本。

## [音频提示改进](https://code.visualstudio.com/updates/v1_66#_audio-cue-improvements)

新设置 （0-100，默认值为50）可用于控制音频提示的音量。还有一个更新的音频提示折叠区域。

## [侧面板和侧栏的新名称](https://code.visualstudio.com/updates/v1_66#_new-names-for-side-panel-and-side-bar)

两个版本之前，我们引入了[侧面板](https://code.visualstudio.com/updates/v1_64#_new-side-panel)。当时，我们删除了将包含终端的底部面板移到侧面的功能，以支持新的一致命令。在听取用户反馈后，我们确定这一决定破坏了一些重要的工作流程，我们决定恢复这一更改。

这给我们留下了两个面板，面板和侧板，两者都可以放在工作台的侧面。为了解决这个问题并更好地反映新侧面板的方向，我们决定更新侧栏和侧面板的命名。侧边栏现在将被称为主侧边栏在用户界面中，而侧面板现在将被称为辅助侧边栏。

* Side Bar (侧栏) -> Primary Side Bar (主侧栏)
* Side Panel (侧面板) -> Secondary Side Bar (辅助侧栏)

这些名称将反映在整个编辑器的菜单和命令中;但是，没有更改命令ID以防止破坏现有的键绑定。

## 终端显示所有查找匹配项

当在终端中搜索时，搜索词的所有实例现在都将突出显示。当前选择的匹配也有一个特定的高光，可以单独自定义。

您可以通过以 `terminal.findMatch` 为前缀的颜色自定义来微调突出显示颜色的外观。

## [终端命令导航改进](https://code.visualstudio.com/updates/v1_66#_command-navigation-improvements)

一个鲜为人知的功能，已经存在了一段时间，是能够快速导航之间的命令在终端。最初，这是基于按下Enter键的时间，但现在当shell集成启用时，它将升级为使用shell集成知识来更可靠地识别正确的行。此外，现在在命令之间跳转时会显示UI反馈。

可以通过以下键绑定访问此功能：

* Linux/Windows: Ctrl+Up/Down (new)

按住Shift键可在终端中的命令之间进行选择。

## [终端复制的文本保留HTML样式](https://code.visualstudio.com/updates/v1_66#_copied-text-retains-html-styling)

要从终端复制富文本，请运行 `Terminal: Copy Selection as HTML` 或使用终端上下文菜单项复制为HTML。

## [终端最小对比度默认值已更改](https://code.visualstudio.com/updates/v1_66#_minimum-contrast-ratio-default-changed)

&#x20;设置已经存在了一段时间，它可以根据背景颜色动态更改终端中的前景色。在这个版本中，我们将默认值更改为4.5（WCAG AA），以确保无论主题如何都可以访问终端。如果这最终导致颜色出现问题，您可以通过设置`"terminal.integrated.minimumContrastRatio": 1` 来禁用该功能。

## [用于游标索引的监听变量](https://code.visualstudio.com/updates/v1_66#_snippet-variables-for-cursor-index)

有新的代码段变量：`$CURSOR_INDEX` 和 `$CURSOR_NUMBER` 。它们的计算结果为相应游标的索引。后者从1开始，前者从0开始。这些变量的强大之处在于它与多个游标的组合。

例如，下面的代码片段将为每个光标添加一个有序列表项：

```json
"ordered_list": {
  "scope": "markdown",
  "prefix": "ol",
  "body": [
    "$CURSOR_NUMBER. $0"
  ],
  "description": "Add ordered list"
}
```

## [双对彩色化](https://code.visualstudio.com/updates/v1_66#_bracket-pair-colorization)

有一个新的设置 。当设置为 `true` 时，每个括号类型将使用自己的颜色池进行着色。因此，不同类型的嵌套括号将具有相同的颜色。

## [改进的语言检测](https://code.visualstudio.com/updates/v1_66#_improved-language-detection)

在上一次迭代中，我们添加了设置  来配置是否使用新的语言检测策略，该策略考虑到您打开的文件类型。该设置现在默认处于启用状态，并且添加了新的设置  ，以便为该策略的结果提供更多优先级。

## [CSS格式化程序](https://code.visualstudio.com/updates/v1_66#_css-formatter)

内置的CSS扩展现在附带了一个格式化程序。格式化程序与CSS，LESS和SCSS一起工作。它由[JS Beautify库](https://github.com/beautify-web/js-beautify)实现，并带有以下设置：

* &#x20;\- 启用/禁用默认的CSS格式化程序。
* &#x20;\- 用空行分隔规则集。
* &#x20;\- 用新行分隔选择器。
* &#x20;\- 确保在选择器分隔符 '>', '+', '~' (for example, a > b) 周围使用空格字符。

less和scss也有相同的设置。

## [HTML中的JavaScript语义突出显示](https://code.visualstudio.com/updates/v1_66#_javascript-semantic-highlighting-in-html)

我们已经将HTML文件中JavaScript源代码的语义突出显示与您在普通.js文件中看到的一致。

这不仅使代码颜色更加一致，还增加了一些以前缺少的重要语义信息，例如突出显示只读类型。

## [支持笔记本的文档选择器](https://code.visualstudio.com/updates/v1_66#_notebookaware-document-selectors)

我们已经完成了对 `vscode.DocumentType` 的添加。此类型允许您将语言功能（如Go to Definition）与特定文档相关联，它驱动UI，还决定是否向相应的提供程序请求结果。我们添加了一个新属性，允许扩展缩小笔记本类型。例如，`{ language: 'python', notebookType: 'jupyter-notebook'}` 针对所有嵌入在Python笔记本中的Python文档。

## [具有自定义语言ID的输出通道](https://code.visualstudio.com/updates/v1_66#_output-channel-with-custom-language-id)

在这个里程碑中，我们已经完成了[CodeOutputChannel API](https://github.com/microsoft/vscode/blob/dc2f5d8dd1790ac4fc6054e11b44e36884caa4be/src/vscode-dts/vscode.d.ts#L9415) ，以创建具有自定义语言ID的输出通道。这将允许您通过传递语言ID为您的输出通道贡献令牌或语法着色和CodeLens功能。

## [支持 CompletionItem.detail](https://code.visualstudio.com/updates/v1_66#_support-for-completionitemdetail)

Last month, the Debug Adapter Protocol added a detail property to the CompletionItem object. This property is now supported in VS Code. You will see the detail in the suggest widget in the Debug Console.
上个月，SNMP适配器协议向CompletionItem对象添加了一个 `detail` 属性。VS Code现在支持此属性。您将在建议小部件中看到详细信息。

## [InputBox 验证消息严重性](https://code.visualstudio.com/updates/v1_66#_inputbox-validation-message-severity)

我们的InputBox API（通过 `window.showInputBox` 和 `window.outputBox`）提供了验证用户输入的机制。在这次迭代中，我们用一个建议的API来扩展它，以显示严重性。

例如，如果你想根据用户的输入向他们显示一条信息消息，你的验证消息可以返回：

```js
{
  content: 'this is an info message';
  severity: InputBoxValidationSeverity.Info;
}
```

它看起来像这样：

此建议的详细信息可以在 [inputBoxSeverity](https://github.com/microsoft/vscode/blob/68802ccc44e21661aa426bfd211c6e94788aa42b/src/vscode-dts/vscode.proposed.inputBoxSeverity.d.ts) 中找到。

## [内联完成](https://code.visualstudio.com/updates/v1_66#_inline-completions)

我们继续致力于内联完成，为下两个版本的最终完成做准备。内联补全现在可以用于建议片段或文本替换（以前只支持文本插入）

## [拖拽到编辑器](https://code.visualstudio.com/updates/v1_66#_drop-into-editor)

建议的[文本编辑器拖放API](https://github.com/microsoft/vscode/blob/bfc026b97a1c28d8288aa2510c066d03e5bcde54/src/vscode-dts/vscode.proposed.textEditorDrop.d.ts)允许扩展处理到文本编辑器中的拖放。这些拖拽事件可以来自VS Code（例如将文件从VS Code的资源管理器拖到文本编辑器中），也可以通过将文件从操作系统拖拽到VS Code中来生成。

## [Electron 17 update](https://code.visualstudio.com/updates/v1_66#_electron-17-update)

在这个里程碑中，我们很高兴在VS Code中发布Electron v17。这是我们之前采用Electron v13的一个重大更新，并利用了Electron的[流程重用架构](https://github.com/electron/electron/issues/18397)。在过去的一年里，我们一直在重新实现并逐步推出一些核心服务的更改，这些更改涉及与工作台相关的交互和生命周期，为新架构做准备：

* File Watcher 文件监视器
* Integrated Terminal 集成终端
* Extension host 扩展主机
* Search 搜索

像切换磁盘和重新加载磁盘这样的操作现在应该更快了。通过此更新，我们还将Chromium版本提升到98.0.4758.109，Nodejs版本提升到16.13.0

---

---
url: /release_notes/kkqwfnpu/index.md
---
# VSCode 1.93 (2024 年 8 月)
> 主要内容摘抄自 [VSCode 1.93 发行说明](https://vscode.js.cn/updates/v1_93)，文中“我们”即 VSCode

## [从设置编辑器复制设置 URL](https://vscode.js.cn/updates/v1_93#_copy-settings-url-from-settings-editor)

---

---
url: /release_notes/kpakwujf/index.md
---
# VSCode 1.79
> 主要内容摘抄自 [VSCode 1.79 发行说明](https://code.visualstudio.com/updates/v1_79)，文中“我们”即 VSCode

## [只读模式](https://code.visualstudio.com/updates/v1_79#_readonly-mode)

在某些开发方案中，将工作区的某些文件夹或文件显式标记为只读可能会有所帮助。例如，如果文件夹或文件内容由不同的进程（例如Node.js包管理器管理的node\_modules文件夹）进行管理，则将它们标记为只读可以避免无意中的更改。

对于此用例，有一些新设置可以在资源管理器以及文本和笔记本编辑器中将文件路径标记为只读：

* &#x20;\- 如果匹配，则将文件设为只读的路径或 glob 模式。
* &#x20;\- 当文件与 files.readonlyInclude 匹配时，用于跳过只读文件的路径或 glob 模式。
* &#x20;\- 磁盘上没有写入权限的文件是否应为只读文件。

根据设置规则，如果路径被视为只读，则无法从资源管理器中修改它（例如，删除它），并且文本或笔记本编辑器是只读的。

对于只读模式的更多临时切换，可以使用新命令仅更改当前会话的模式，从而推翻您的设置配置：

* `Set Active Editor Readonly in Session` - 将活动编辑器标记为只读。
* `Set Active Editor Writeable in Session` - 将活动编辑器标记为可写。
* `Toggle Active Editor Readonly in Session` - 在只读和可写之间切换。
* `Reset Active Editor Readonly in Session` - 重置会话状态。

## [修复了新的选项卡大小调整选项](https://code.visualstudio.com/updates/v1_79#_new-tab-sizing-option-fixed)

&#x20;设置修复了一个新选项，该选项使每个选项卡的宽度相等。当空间变得有限时，选项卡将同样缩小到最小值。新设置  设置选项卡的初始大小。

在此模式下，当您使用鼠标快速关闭选项卡时，选项卡的宽度将保持稳定，以便通过单击同一点来关闭每个选项卡。然后，当您将鼠标从编辑器选项卡区域离开时，将调整宽度。

## [网络质量指示](https://code.visualstudio.com/updates/v1_79#_network-quality-indication)

连接到远程计算机时，VS Code 远程编辑功能的最佳体验需要良好的网络连接和低延迟。在这个里程碑中，我们更新了状态栏中的远程指示器，以便在延迟非常高或网络连接似乎离线时为您提供一些反馈。

## [默认分支名称](https://code.visualstudio.com/updates/v1_79#_default-branch-name)

从此里程碑开始，使用 VS Code 创建的所有新 Git 存储库都将 main 设置为其默认分支。如果您更喜欢为默认分支使用不同的名称，可以使用  设置进行更改。当设置设置为空时，VS Code 将遵循 Git 中配置的默认分支名称。将文件夹发布到 GitHub 也会遵循在 GitHub 上配置的默认分支名称。

## [JSX 标签的链接编辑](https://code.visualstudio.com/updates/v1_79#_linked-editing-for-jsx-tags)

使用链接编辑时，当您更改开始 JSX 标签时，VS Code 将自动更新相应的结束标签。这可以节省大量时间

默认情况下，该功能处于关闭状态，但可以通过设置来启用：

```json
"editor.linkedEditing": true
```

您还可以使用 `Start Linked Editing` 命令显式启动链接编辑。

## [在拖放或粘贴 Markdown 时将外部媒体文件复制到工作区](https://code.visualstudio.com/updates/v1_79#_copy-external-media-files-into-workspace-on-drop-or-paste-for-markdown)

想要将图像或视频添加到 Markdown 文档中？现在，您无需浪费时间先手动将文件复制到工作区，然后再添加链接，只需将文件拖放或粘贴到 Markdown 中即可。如果文件当前不是工作区的一部分，VS Code 会自动将文件复制到工作区并插入指向它的链接

这也适用于剪贴板中的图像数据。例如，如果在 Windows 上使用截图工具截取屏幕截图，则可以在 Markdown 文件中按“粘贴”，VS Code 将从剪贴板数据创建一个新的图像文件，并将 Markdown 图像链接插入到新文件。如果您在截取屏幕截图以将其复制到剪贴板时按住 Ctrl 键，这也适用于 macOS。

您还可以使用一些设置来自定义此功能的行为：

### markdown.copyFiles.destination

&#x20;设置控制创建新媒体文件的位置。此设置将在当前 Markdown 文档上匹配的 glob 映射到图像目标。图像目标还可以使用一些简单的变量。有关可用变量的信息，请参阅 `markdown.copyFiles.destination` 设置说明。

例如，如果我们希望工作区中 /docs 下的每个 Markdown 文件都将新的媒体文件放入特定于当前文件的图像目录中，我们可以编写：

```json
"markdown.copyFiles.destination": {
  "/docs/**/*": "images/${documentBaseName}/"
}
```

现在，当将新文件粘贴到 `/docs/api/readme.md` 中时，将在 `/docs/api/images/readme/image.png` 中创建图像文件。

您甚至可以使用简单的正则表达式以类似于代码段的方式转换变量。例如，在创建媒体文件时，此转换仅使用文档文件名的第一个字母

```json
"markdown.copyFiles.destination": {
  "/docs/**/*": "images/${documentBaseName/(.).*/$1/}/"
}
```

当将新文件粘贴到 `/docs/api/readme.md` 时，图像现在会在 `/docs/api/images/r/image.png` 下创建。

### markdown.copyFiles.overwriteBehavior

&#x20;设置控制新创建的媒体文件是否覆盖现有文件。

默认情况下，VS Code 永远不会覆盖现有文件。相反，如果你有一个名为 `image.png` 的文件，并尝试将其粘贴到已存在 `image.png` 的工作区中的 Markdown 文档中，VS Code 将改为创建一个名为 `image-1.png` 的新文件。如果您随后尝试粘贴另一个名为 `image.png` 的文件，它将被创建为 `image-2.png` 。

如果您更喜欢让现有文件被新文件覆盖，请设置 `"markdown.copyFiles.overwriteBehavior": "overwrite"` 。现在，VS Code 将始终使用原始文件名，覆盖该路径的任何现有文件。

### 禁止将文件复制到工作区

VS Code 只会尝试将文件复制到工作区中，前提是它们还不是工作区的一部分。此外，我们目前仅将媒体文件（图像、视频、音频）复制到工作区。

但是，如果您发现这种新行为过于侵入性，您可以通过设置来禁用它以进行拖放和粘贴：

```json
"markdown.editor.drop.copyIntoWorkspace": "never"
"markdown.editor.filePaste.copyIntoWorkspace": "never"
```

## [Markdown 文件中的 HTML 路径的 IntelliSense](https://code.visualstudio.com/updates/v1_79#_intellisense-for-html-paths-in-markdown-files)

许多 Markdown 方言允许在 Markdown 文档中使用原始 HTML 标签。在此更新中，我们已将 VS Code 的大部分 Markdown IntelliSense 功能扩展到这些 HTML 标记中使用的文件路径。这包括对以下各项的支持：

* 路径完成。
* 查找对链接到文件的所有引用。
* 重命名或移动文件时自动更新文件路径。
* 使用 F2 安全地重命名文件。
* 验证链接到的文件是否存在于工作区中。

## [改进了本地文件的 vscode.fs 性能](https://code.visualstudio.com/updates/v1_79#_improved-vscodefs-performance-for-local-files)

当您使用 `vscode.fs` API 处理文件时（您应该这样做！），现在对扩展主机本地文件的操作将更快地解决。

以前，扩展主机会将这些操作委托给 VS Code 客户端执行，但现在它们直接在扩展主机内部执行，从而节省了往返行程。

## [更严格的状态栏 API](https://code.visualstudio.com/updates/v1_79#_stricter-status-bar-api)

用于创建状态栏项的 API createStatusBarItem 允许扩展传递标识符。此标识符用于控制隐藏和显示状态栏项。标识符对于扩展应该是唯一的，但直到现在还没有强制执行。在此版本中，我们对此进行了更严格的操作，并且由具有相同标识符的同一扩展创建的状态栏项现在将合并为一个。

## [在任务完成时关闭终端的任务呈现选项已经完成](https://code.visualstudio.com/updates/v1_79#_tasks)

---

---
url: /release_notes/l3lv16um/index.md
---
# VSCode 1.86 (2024 年 1 月)
> 主要内容摘抄自 [VSCode 1.86 发行说明](https://code.visualstudio.com/updates/v1_86)，文中“我们”即 VSCode

## [配置每个窗口的缩放级别](https://code.visualstudio.com/updates/v1_86#_configure-zoom-levels-per-window)

新设置 （默认启用）允许您配置缩放命令（放大、缩小、缩放重置）以仅应用于活动窗口，而不适用于所有打开的窗口。以前，使用这些命令不仅会将其应用于所有打开的窗口，而且还会更新  设置。

我们认为，使用这些命令更像是一种临时手势，例如在进行演示时，因此应该只适用于从中调用它们的窗口。

当窗口的自定义缩放级别与 `window.zoomLevel` 设置值不匹配时，状态栏中会显示缩放级别指示器。选择状态栏指示器以查找用于更改缩放级别、重置缩放级别或快速转到相关设置的控件。

具有自定义缩放级别的窗口在重新启动和工作区更改时保留该缩放级别。

> 注意：将 `window.zoomPerWindow` 配置为 `false` 以恢复之前的缩放级别行为。

## [更强大、更灵活的自动保存选项](https://code.visualstudio.com/updates/v1_86#_more-powerful-and-flexible-auto-save-options)

VS Code 长期以来一直提供自动保存选项。在此版本中，我们使此功能更加强大。

### 配置每种资源或语言的自动保存

现在，所有自动保存设置都可以按文件夹或语言进行配置，这使您可以选择性地仅为特定语言或文件夹启用自动保存。

在下面的示例中，设置配置为：

```json
{
  "[markdown]": {
    "files.autoSave": "afterDelay"
  }
}
```

### [禁用出错时自动保存](https://code.visualstudio.com/updates/v1_86#_disable-auto-save-when-errors)

通过新的  设置，如果文件中存在错误标记，则可以禁用“自动保存”，而“自动保存”通常会保存编辑器。

当您有外部工具监视文件更改时，这可能很有用，因为在外部工具中，您希望避免这些工具对包含错误的已更改文件执行操作。

### [仅自动保存工作区文件](https://code.visualstudio.com/updates/v1_86#_auto-save-for-workspace-files-only)

最后，新设置  将“自动保存”限制为仅对工作区内的文件。

## [允许禁用每个扩展程序的通知](https://code.visualstudio.com/updates/v1_86#_allow-disabling-notifications-per-extension)

现在，我们提供更精细的控制功能，用于禁用来自扩展程序的通知。在通知 Toast 中，您可以禁用扩展的通知。

在“通知中心”中，有一个中心位置可用于管理已触发通知的所有扩展的通知启用。

这项新功能补充了我们现有的“勿扰模式”，该模式会全局禁用所有通知。与全局开关一样，错误通知将始终出现，并且无法禁用。

## [允许交换左右差异编辑器](https://code.visualstudio.com/updates/v1_86#_allow-swapping-left-and-right-diff-editors)

当您比较两个文件（例如，从文件资源管理器中）时，会出现一个新操作来交换差异编辑器的左侧和右侧。

> 注意：比较两个可编辑文件允许您在任一侧进行更改。

## [在新窗口中打开“输出”面板](https://code.visualstudio.com/updates/v1_86#_open-output-panel-in-a-new-window)

现在，“输出”面板在面板标题菜单中具有“在新窗口中打开输出”操作，用于在单独的窗口中查看“输出”面板。

## [从 CLI 更新扩展](https://code.visualstudio.com/updates/v1_86#_update-extensions-from-cli)

现在，您可以使用 `--update-extensions` 参数从命令行更新扩展。这会将所有已安装的扩展更新到最新版本。

## [粘贴文本/html 内容](https://code.visualstudio.com/updates/v1_86#_paste-texthtml-content)

“粘贴为...” (`Paste As`) 命令现在允许您在剪贴板中粘贴文本/html 内容。

## [源代码管理提交输入自定义项](https://code.visualstudio.com/updates/v1_86#_commit-input-customizations)

在这个里程碑中，我们添加了一个新设置  ，可用于控制提交输入字段的初始高度。控制提交输入字段最大大小的设置已从 `scm.inputMaxLines` 重命名为 `scm.inputMaxLineCount` ，以便与类似设置的命名约定匹配。

用户现在可以使用特定于语言的编辑器设置来进一步自定义提交输入字段。特定于语言的编辑器设置可用于定义编辑器规则和禁用自动换行：

```json
"[scminput]": {
    "editor.rulers": [
      50,
      72
    ],
    "editor.wordWrap": "off"
  }
```

## [源代码管理存储库视图改进](https://code.visualstudio.com/updates/v1_86#_source-control-repositories-view-improvements)

为了帮助更好地管理具有大量仓库的工作区，我们在仓库上下文菜单中添加了一个新命令：关闭其他仓库。我们还添加了对“关闭仓库”和“关闭其他仓库”命令的多选支持，因此用户可以一次关闭多个仓库，或者关闭除少数仓库以外的所有仓库。

由于扩展参与的操作，“源代码管理存储库”视图可能会变得拥挤。为了帮助解决这个问题，我们添加了隐藏贡献的操作的功能，方法是右键单击操作并选择隐藏。隐藏的操作将移至“...”菜单中。除 `Checkout` 和 `Sync` 之外的所有操作都可以隐藏。

## [传入/传出更改改进](https://code.visualstudio.com/updates/v1_86#_incomingoutgoing-changes-improvements)

我们将继续完善“源代码管理”视图中的“传入/传出更改”部分。在此里程碑中，我们进行了更改，以便仅当当前分支具有跟踪远程分支时，才会显示“传入更改”节点。

我们已将 Fetch 和 Pull 操作添加到 Incoming changes 节点，并将 Push 操作添加到 Outgoing changes 节点。

我们添加了操作来查看每个单独的提交，以及利用多文件差异编辑器的所有传入/传出更改。

用户现在可以使用新设置  来隐藏“所有更改”条目

## [能够合并标签](https://code.visualstudio.com/updates/v1_86#_ability-to-merge-tags)

我们通过添加合并标签的功能解决了一个长期存在的功能请求。命令面板中添加了一个新命令 `Git: Merge...` ，该命令替换了 `Git: Merge Branch...` 命令。调用 `Git: Merge...` 命令将显示一个快速选取控件，其中列出了分支和标签。

## [“查看存储”命令](https://code.visualstudio.com/updates/v1_86#_view-stash-command)

我们添加了一个新命令 `Git: View Stash...` ，使用户能够在多文件差异编辑器中查看存储库中的任何存储。查看 git 仓库时，编辑器标题菜单将包含要应用/弹出或删除仓库的操作。

## [Notebook 内置变量视图](https://code.visualstudio.com/updates/v1_86#_builtin-variable-view)

我们在 Run 和 Debug 视图中添加了一个实验变量视图，如果扩展提供这些变量，则该视图可用于查看笔记本内核中的变量。可以使用以下设置启用此功能：

```json
"notebook.experimental.variablesView": true
```

## [Notebook 粘性卷轴](https://code.visualstudio.com/updates/v1_86#_notebook-sticky-scroll)

笔记本编辑器的 Sticky Scroll 功能得到了重大改进，使其样式与工作台的其余部分保持一致，并为每个 markdown 元素添加折叠控件。

## [通过鼠标滚轮缩放终端](https://code.visualstudio.com/updates/v1_86#_zoom-terminal-via-mouse-wheel)

现在，当启用此设置时，可以在按住 Ctrl 的同时使用鼠标滚轮放大和缩小终端：

```json
"terminal.integrated.mouseWheelZoom": true
```

## [终端中的链接改进](https://code.visualstudio.com/updates/v1_86#_link-improvements)

文件协议 URI （`file://`） 现在支持末尾的行号和列号扩展，就像大多数其他链接一样。还支持新的 `#<line>` 格式。

## [任务配置路径分隔符变量的简写](https://code.visualstudio.com/updates/v1_86#_shorthand-for-path-separator-variable)

新的 `${/}` 变量可以用作现有 `${pathSeparator}` 变量的简写。

## [粘贴 URL 以自动创建 Markdown 链接](https://code.visualstudio.com/updates/v1_86#_paste-a-url-to-automatically-create-a-markdown-link)

想要将您复制的链接转换为 Markdown 链接吗？当您将 URL 粘贴到选中文本的 Markdown 文件中时，VS Code 现在会自动插入 Markdown 链接。

此功能由  设置控制。您可以更改它以自定义此行为：

* smartWithSelection — 默认值。当您选择了文本并且不在特殊元素（如代码块）中时，这将启用该功能。
* smart — 与 smartWithSelection 相同，但不需要选择。
* always — 始终将 url 粘贴为 Markdown 链接
* never — 禁用粘贴为 Markdown 链接。

## [新的 workspace.save 和 workspace.saveAs API](https://code.visualstudio.com/updates/v1_86#_new-workspacesave-and-workspacesaveas-apis)

新的最终确定的 API `workspace.save` 和 `workspace.saveAs` 允许扩展触发保存编辑器的流程，无论是保存到其资源，还是通过要求用户提供资源。

所有保存方法都返回生成的 Uri，如果操作已取消，则返回 undefined。除非已关联路径，否则无标题文件将始终要求用户提供目标。

## [FileSystemProvider API 的只读消息](https://code.visualstudio.com/updates/v1_86#_readonly-message-for-filesystemprovider-api)

使用 registerFileSystemProvider 注册 FileSystemProvider 时，可以设置选项以将整个文件系统标记为只读。现在，如果将 isReadonly 选项设置为 MarkdownString，则当用户尝试在文件系统中编辑文件时，该消息将显示在编辑器中。

## [Electron 27 更新](https://code.visualstudio.com/updates/v1_86#_electron-27-update)

在这个里程碑中，我们将在我们的稳定版本中向用户推广 Electron 27 更新。此更新附带 Chromium 118.0.5993.159 和 Node.js 18.17.1

## [Linux 最低要求更新](https://code.visualstudio.com/updates/v1_86#_linux-minimum-requirements-update)

在这个里程碑中，我们更新了工具链以构建我们的桌面客户端。从此版本开始，VS Code 桌面仅与基于 glibc 2.28 或更高版本以及 glibcxx 3.4.25 或更高版本的 Linux 发行版兼容，例如 Debian 10、RHEL 8 或 Ubuntu 20.04。

---

---
url: /release_notes/lkrcosqf/index.md
---
# VSCode 1.97 (2025 年 1 月)
> 主要内容摘抄自 [VSCode 1.97 发行说明](https://vscode.js.cn/updates/v1_97)，文中“我们”即 VSCode

## [复合日志](https://vscode.js.cn/updates/v1_97#_compound-logs)

有时，您会发现信息分散在多个日志中，需要将它们一起查看才能获得完整的情况。现在，您可以在一个复合日志视图中查看多个日志。结合新的筛选功能，分析日志变得更好了！

要创建自定义复合日志，请使用“输出”面板溢出菜单中的“创建复合日志...”操作。

## [扩展筛选器增强](https://vscode.js.cn/updates/v1_97#_extension-filter-enhancements)

为了帮助您跟踪有可用更新的扩展以及查找最近更新的扩展，您现在在“扩展”视图中有了两个新的筛选选项：`@outdated` 和 `@recentlyUpdated` 。

## [单元格执行时的内联值](https://vscode.js.cn/updates/v1_97#_inline-values-upon-cell-execution)

现在，Notebook 编辑器支持在单元格执行后通过设置  显示内联值。启用后，在成功执行单元格后，将根据已注册的 InlineValueProvider 的结果显示内联值。

如果没有提供者，则回退方法通过简单的正则表达式匹配将内核中找到的值与单元格文档进行匹配。建议使用语言扩展提供的提供者以确保更准确的结果。

---

---
url: /release_notes/mh24jd7x/index.md
---
# VSCode 1.103 (2025 年 7 月)
> 主要内容摘抄自 [VSCode 1.103 发行说明](https://vscode.js.cn/updates/v1_103)，文中“我们”即 VSCode

## [在用 uv 创建的虚拟环境中安装依赖项](https://vscode.js.cn/updates/v1_103#_install-dependencies-in-virtual-environments-created-with-uv)

现在，当您针对使用 uv 创建的虚拟环境运行 Jupyter Notebook 时，我们支持安装所需的依赖项。

## [仓库视图](https://vscode.js.cn/updates/v1_103#_repositories-view)

在此里程碑中，我们更新了视图的渲染，以便在视觉上区分仓库、子模块和工作区。我们还显示了仓库、子模块和工作区之间的父子关系。

## [终端激活事件](https://vscode.js.cn/updates/v1_103#_terminal-activation-events)

有两个新的激活事件可用于扩展：

```
onTerminal：当任何终端打开时触发。
onTerminalShellIntegration：当终端的富 Shell 集成激活时触发。
```

您可以指定 shellType 来定位特定的 shell。例如，当 Bash 终端启用 Shell 集成时，onTerminalShellIntegration:bash 会激活。

---

---
url: /release_notes/nhbjh44o/index.md
---
# v3.1.0
## 概述

该版本支持了只读发布服务，改进了网页剪藏，修复了一些缺陷并改进了许多细节。

## 变更记录

以下是此版本中的详细变更。

### 引入特性

* [支持只读发布服务](https://github.com/siyuan-note/siyuan/pull/11367)

### 改进功能

* [在创建空文档后改进交互指导](https://github.com/siyuan-note/siyuan/issues/10528)
* [改进行级元素的菜单交互](https://github.com/siyuan-note/siyuan/issues/10577)
* [改进展开标题的性能](https://github.com/siyuan-note/siyuan/issues/10935)
* [改进 PDF 导出](https://github.com/siyuan-note/siyuan/issues/11258)
* [复制数据库表视图字段时保持宽度](https://github.com/siyuan-note/siyuan/issues/11552)
* [改进 HTML 实体剪藏](https://github.com/siyuan-note/siyuan/issues/11557)
* [改进带数据库的文档复制](https://github.com/siyuan-note/siyuan/issues/11602)
* [改进列表项末尾删除](https://github.com/siyuan-note/siyuan/issues/11606)
* [改进 HTML 标签输入](https://github.com/siyuan-note/siyuan/issues/11622)
* [属性面板 - 数据库支持右键点击字段](https://github.com/siyuan-note/siyuan/issues/11625)
* [转换列表支持配置快捷键](https://github.com/siyuan-note/siyuan/issues/11634)
* [改进 `Ctrl+P` 和 `Ctrl+F`](https://github.com/siyuan-note/siyuan/issues/11637)
* [改进维基百科剪藏](https://github.com/siyuan-note/siyuan/issues/11640)
* [改进 HTML 代码剪藏](https://github.com/siyuan-note/siyuan/issues/11642)
* [改进网页剪藏转义代码块标记](https://github.com/siyuan-note/siyuan/issues/11643)
* [改进 `添加到数据库` 搜索](https://github.com/siyuan-note/siyuan/issues/11644)
* [改进 StackExchange 公式剪藏](https://github.com/siyuan-note/siyuan/issues/11646)
* [改进代码块中的光标移动](https://github.com/siyuan-note/siyuan/issues/11647)
* [在文档树面板中显示“已关闭笔记本”的数量](https://github.com/siyuan-note/siyuan/issues/11648)
* [Windows arm64 和 Linux arm64 不再打包 pandoc](https://github.com/siyuan-note/siyuan/issues/11649)
* [改进知乎公式剪藏](https://github.com/siyuan-note/siyuan/issues/11653)
* [在书签面板显示数据库标题](https://github.com/siyuan-note/siyuan/issues/11666)
* [改进 Mermaid 的 Markdown 渲染](https://github.com/siyuan-note/siyuan/issues/11670)
* [改进 Shift+↑/↓ 选择](https://github.com/siyuan-note/siyuan/issues/11671)
* [改进分屏中打开文档的位置](https://github.com/siyuan-note/siyuan/issues/11676)
* [在开头粘贴块并将其插入上方](https://github.com/siyuan-note/siyuan/issues/11677)
* [上传资源时从文件名中移除不可见字符](https://github.com/siyuan-note/siyuan/issues/11683)
* [改进移动端自定义表情渲染](https://github.com/siyuan-note/siyuan/issues/11690)
* [改进表格中的 ↑/↓ 移动](https://github.com/siyuan-note/siyuan/issues/11694)
* [导出 .sy.zip 和 data.zip 时显示详情](https://github.com/siyuan-note/siyuan/issues/11696)
* [在快捷键设置中按辅助键时无提示](https://github.com/siyuan-note/siyuan/issues/11720)
* [改进嵌入块导出](https://github.com/siyuan-note/siyuan/issues/11725)
* [改进文档标题中 `↓` 的使用](https://github.com/siyuan-note/siyuan/issues/11729)
* [只读模式下禁用一些菜单项](https://github.com/siyuan-note/siyuan/pull/11733)
* [改进行级元素粘贴](https://github.com/siyuan-note/siyuan/issues/11740)
* [改进 HTML 公式剪藏](https://github.com/siyuan-note/siyuan/issues/11743)
* [自定义表情文件夹更改时不再需要手动刷新](https://github.com/siyuan-note/siyuan/issues/11749)
* [图片居中后改进选择操作](https://github.com/siyuan-note/siyuan/issues/11757)
* [在 PDF 标签的右键菜单中添加“复制”](https://github.com/siyuan-note/siyuan/issues/11758)
* [改进包含图片的块的多重选择](https://github.com/siyuan-note/siyuan/issues/11763)
* [改进表情搜索](https://github.com/siyuan-note/siyuan/pull/11768)
* [改进导出 PDF 注释超链接的页码显示](https://github.com/siyuan-note/siyuan/issues/11780)
* [改进 HTML 表格剪藏](https://github.com/siyuan-note/siyuan/issues/11783)
* [导出块引用 `锚点哈希` 支持文档级别](https://github.com/siyuan-note/siyuan/issues/11814)
* [改进字体家族](https://github.com/siyuan-note/siyuan/issues/11841)
* [如果笔记本配置改变，数据同步后重新索引笔记本并重新加载界面](https://github.com/siyuan-note/siyuan/issues/11850)

### 修复缺陷

* [移动超级块的子块异常](https://github.com/siyuan-note/siyuan/issues/11609)
* [在多窗口编辑时，文档无法在新窗口正常打开](https://github.com/siyuan-note/siyuan/issues/11610)
* [移动端无法使用 `添加到数据库`](https://github.com/siyuan-note/siyuan/issues/11651)
* [拖动和撤销 HTML 块将显示标签](https://github.com/siyuan-note/siyuan/issues/11656)
* [移动文档后无法重命名](https://github.com/siyuan-note/siyuan/issues/11661)
* [图片标题的转义内容重复](https://github.com/siyuan-note/siyuan/issues/11681)
* [启用自适应宽度时，IFrame 块不会调整大小](https://github.com/siyuan-note/siyuan/issues/11695)
* [含有 `%` 的行级备注无法显示](https://github.com/siyuan-note/siyuan/issues/11709)
* [行级元素中 `Shift+Enter` 无法正常工作](https://github.com/siyuan-note/siyuan/issues/11766)
* [在行级代码内粘贴转义文本异常](https://github.com/siyuan-note/siyuan/issues/11778)
* [无法编辑 AI 自定义操作](https://github.com/siyuan-note/siyuan/issues/11791)
* [使用 `Ctrl+X` 应剪切嵌入块本身](https://github.com/siyuan-note/siyuan/issues/11793)
* [有时音频或视频无法播放](https://github.com/siyuan-note/siyuan/issues/11810)
* [搜索界面 XSS](https://github.com/siyuan-note/siyuan/issues/11848)
* [代码块语言搜索 XSS](https://github.com/siyuan-note/siyuan/issues/11869)

### 改进文档

* [改进用户指南类型过滤章节](https://github.com/siyuan-note/siyuan/pull/11692)

### 开发重构

* [升级 mermaid v10.9.1](https://github.com/siyuan-note/siyuan/issues/11645)
* [升级 Electron v31.1.0](https://github.com/siyuan-note/siyuan/issues/11654)
* [重构块树存储](https://github.com/siyuan-note/siyuan/issues/11773)

### 开发者

* [内核 API OCR 返回文本坐标信息](https://github.com/siyuan-note/siyuan/pull/11738)
* [添加内部内核 `/api/attr/batchGetBlockAttrs`](https://github.com/siyuan-note/siyuan/issues/11786)

---

---
url: /release_notes/onfktfhf/index.md
---
# VSCode 1.72
> 主要内容摘抄自 [VSCode 1.72 发行说明](https://code.visualstudio.com/updates/v1_72)，文中“我们”即 VSCode

## [选择使用 3 向合并编辑器](https://code.visualstudio.com/updates/v1_72#_opt-in-to-use-the-3way-merge-editor)

在审查了我们收到的所有合并编辑器反馈并考虑了整个体验之后，我们决定在检测到冲突时默认不显示 3 向合并编辑器（git.mergeEditor 设置现在为 false）。此决定的原因可以在 [issue #160806](https://github.com/microsoft/vscode/issues/160806) 中找到。

## [从头开始重新计算的结果文件](https://code.visualstudio.com/updates/v1_72#_opt-in-to-use-the-3way-merge-editor)

在上一次迭代中，我们尝试将合并编辑器设计为有冲突的文件的替代视图。单独的编辑器窗格不显示冲突标记，而是显示冲突的详细信息。这种设计的优点是打开合并编辑器不会修改磁盘上的文件，并且可以保留在打开合并编辑器之前所做的用户更改。不幸的是，这不仅令人困惑，而且并非在所有情况下都有效，因为我们的合并算法和 Git 合并算法没有完全对齐。

在此版本中，如果在合并编辑器中打开带有冲突标记的文件，作为第一步，我们将使用合并算法重新计算结果文件，而不插入任何冲突标记。单方面的冲突将自动解决，正确的冲突将重置为两个版本的共同祖先，并标记为未处理。

## [改进了编辑器自动滚动行为](https://code.visualstudio.com/updates/v1_72#_improved-autoscroll-behavior)

在选择和拖动时，编辑器过去常常以依赖于显示器的每秒帧数 （FPS） 的方式滚动，有时编辑器会在鼠标到达编辑器边缘时快速滚动。现在，编辑器以更易于管理的速度自动滚动，当鼠标靠近边缘时，大约每秒一个视口，当鼠标远离编辑器时，速度更快，与 FPS 无关。

## [改进的悬停](https://code.visualstudio.com/updates/v1_72#_improved-hover)

编辑器悬停过去在隐藏自身方面非常激进，尤其是当鼠标经过编辑器的空白区域时。这使得难以达到悬停中显示的某些动作。现在，只要鼠标向悬停方向移动，悬停就会保持可见。设置 `"editor.hover.sticky": false` 将恢复到之前的行为。

## [最近更新的扩展](https://code.visualstudio.com/updates/v1_72#_recently-updated-extensions)

VS Code 现在在扩展视图的“更新”的“最近更新”部分中显示过去 7 天内更新的扩展。

## [需要注意的扩展](https://code.visualstudio.com/updates/v1_72#_extensions-requiring-attention)

VS Code 现在显示需要注意的扩展，这些扩展被排序到扩展视图的默认已安装部分的顶部。这包括具有挂起更新或已更新或禁用并需要 VS Code 重新加载的扩展。

现在，“活动栏”中“扩展”图标上的标记显示需要注意的扩展数量。

## [忽略扩展的更新](https://code.visualstudio.com/updates/v1_72#_ignore-updates-for-an-extension)

现在，您可以通过单击“更新”下拉菜单中的“忽略更新”按钮来忽略扩展的更新。这将从“需要注意的扩展”列表中删除该扩展。

您可以通过取消选中相同的“忽略更新”按钮来撤消此操作。

请注意，安装扩展的特定版本（通过“安装另一个版本”）也将忽略该扩展的更新。

## [已安装扩展的排序](https://code.visualstudio.com/updates/v1_72#_sorting-of-installed-extensions)

现在，您可以按“安装计数”、“评级”、“名称”、“发布日期”和“更新日期”对已安装的扩展列表进行排序。

## [搜索结果显示为树视图](https://code.visualstudio.com/updates/v1_72#_results-displayed-as-a-tree-view)

您现在可以在树中查看搜索结果！只需单击搜索视图顶角的列表/树图标，即可在列表和树视图之间切换。

## [发现嵌套的 Git 存储库](https://code.visualstudio.com/updates/v1_72#_discover-nested-git-repositories)

为了解决长期存在的功能请求，我们在这个里程碑上对存储库发现进行了更改，以添加对嵌套 Git 存储库的支持。根据嵌套仓库的位置，您可能需要修改  设置（默认值为 1 级）。

## [存储库 fetch 改进](https://code.visualstudio.com/updates/v1_72#_repository-fetch-improvements)

对于具有多个远程的 Git 存储库，调用 fetch 命令现在将显示一个 Quick Pick，其中包含所有远程的列表。用户可以选择要获取的特定远程或从所有远程获取。

## [中止合并命令](https://code.visualstudio.com/updates/v1_72#_abort-merge-command)

There is a new command, Git: Abort Merge, to abort a merge operation that is currently in progress.
有一个新命令 `Git: Abort Merge` ，用于中止当前正在进行的合并操作。

## [GitHub Issue Notebooks 扩展](https://code.visualstudio.com/updates/v1_72#_github-issue-notebooks)

[GitHub Issue Notebooks](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-github-issue-notebooks\&ssr=false#overview) 扩展展示了笔记本 API，并且非常方便。本着这种精神，我们采用了工作区编辑 API 的最新改进。有一些新的代码操作：

* 将单元格移动/复制到新笔记本中。
* 允许您使用 OR 语句拆分单元格。
* 使用代码段编辑将符合条件的值（如 `label:bug` ）提取到变量中。
* 基于代码段的值集错误的快速修复。

## [Jupyter 的一些改进](https://code.visualstudio.com/updates/v1_72#_jupyter)

## [在干净的环境中进行扩展调试](https://code.visualstudio.com/updates/v1_72#_extension-debugging-in-a-clean-environment)

在调试扩展时，始终存在一个问题，即扩展在扩展作者的开发环境（用户设置和已安装的扩展）中运行，而不是在更适合扩展目标用户的环境中运行。

借助最近引入的“配置文件”功能，现在可以通过在扩展的调试配置中指定配置文件，在不同的环境中运行正在开发的扩展。

支持两种方案：

* 使用未命名的“空”配置文件在干净的环境中进行调试，该配置文件在扩展调试停止时会自动删除。
* 使用专为正在开发的扩展创建的命名配置文件在受控环境中进行调试，该配置文件包含特定的用户设置和扩展。

此调试配置显示如何使用 --profile-temp 开关在干净的环境中进行调试：

```json
{
  "name": "Extension",
  "type": "extensionHost",
  "request": "launch",
  "args": ["--profile-temp", "--extensionDevelopmentPath=${workspaceFolder}"],
  "outFiles": ["${workspaceFolder}/dist/**/*.js"],
  "preLaunchTask": "npm: watch"
}
```

下面是一个调试配置，用于在受控环境中进行调试，该环境使用先前创建的名为“extensionContext”的配置文件：

```json
{
  "name": "Extension",
  "type": "extensionHost",
  "request": "launch",
  "args": ["--profile=extensionContext", "--extensionDevelopmentPath=${workspaceFolder}"],
  "outFiles": ["${workspaceFolder}/dist/**/*.js"],
  "preLaunchTask": "npm: watch"
}
```

请注意，在远程位置调试扩展时 （通过远程开发扩展 Dev Containers、SSH 或 WSL） ，使用 --profile-temp 标志将导致以下状态消息。这是意料之中的，因为临时配置文件不包含任何扩展，这意味着远程开发扩展也丢失了。对于远程方案，建议您创建一个空的命名配置文件，向其添加远程开发扩展，然后使用 --profile=.... 命令行选项。

## [树视图 initialSize 贡献已完成](https://code.visualstudio.com/updates/v1_72#_tree-view-initialsize-contribution-finalized)

在 package.json 中提供视图的扩展可以使用 `initialSize` 属性来设置其视图的初始大小。initialSize 的工作方式类似于 CSS flex-grow。

在应用 initialSize 时有一些限制：

* 这只是一个初始大小。一旦呈现了视图，initialSize 将不会再次应用。
* 仅当扩展同时拥有视图和视图容器时，它才适用。

## [树视图 viewBadge 已完成](https://code.visualstudio.com/updates/v1_72#_tree-viewbadge-finalized)

TreeView 有一个可选的 `viewBadge` 属性，可用于在视图的视图容器上设置数字徽章。

## [树项复选框](https://code.visualstudio.com/updates/v1_72#_tree-item-checkboxes)

建议的 `checkboxState` 允许您向树项添加复选框。

## [日志输出通道](https://code.visualstudio.com/updates/v1_72#_log-output-channel)

vscode.window.createOutputChannel API 现在有一个新的日志布尔选项，可用于创建仅用于日志记录的输出通道。

```ts
/**
 * Creates a new {@link LogOutputChannel log output channel} with the given name.
 *
 * @param name Human-readable string which will be used to represent the channel in the UI.
 * @param options Options for the log output channel.
 */
export function createOutputChannel(
  name: string,
  options: { readonly log: true }
): LogOutputChannel;
```

LogOutputChannel 支持以下方法来记录消息

```ts
trace(message: string, ...args: any[]): void;
debug(message: string, ...args: any[]): void;
info(message: string, ...args: any[]): void;
warn(message: string, ...args: any[]): void;
error(error: string | Error, ...args: any[]): void;
```

---

---
url: /release_notes/pne0goul/index.md
---
# VSCode 1.82 (2023 年 8 月)
> 主要内容摘抄自 [VSCode 1.82 发行说明](https://code.visualstudio.com/updates/v1_82)，文中“我们”即 VSCode

## [内置端口转发](https://code.visualstudio.com/updates/v1_82#_builtin-port-forwarding)

VS Code 现在具有内置端口转发系统。此功能允许您通过互联网将本地运行的服务共享给其他人和设备。要使用它，请在面板区域中可用的端口视图中选择转发端口按钮（端口：聚焦端口视图）。
[请参阅端口转发](https://code-visualstudio-com.translate.goog/docs/editor/port-forwarding?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN)用户指南，了解有关端口转发的更多信息。
命令中心现在默认开启

## [命令中心现在默认开启](https://code.visualstudio.com/updates/v1_82#_command-center-now-on-by-default)

几个月前，我们引入了命令中心，作为发现和与 VS Code 交互的快捷方式。您可以将其用作启动板，在命令面板中查找命令、运行任务和其他快速体验。我们一直在进行一项实验，在标题栏中显示命令中心，并得到了积极的反馈，因此我们觉得是时候默认启用它了。

## [状态栏的新主题颜色和更新主题颜色](https://code.visualstudio.com/updates/v1_82#_new-and-updated-themable-colors-for-the-status-bar)

状态栏已为其项目提供了许多可主题化的颜色。现在有更多颜色可用于主题化悬停前景色和背景色：

* statusBarItem.errorHoverBackground
* statusBarItem.errorHoverForeground
* statusBarItem.warningHoverBackground
* statusBarItem.warningHoverForeground
* statusBarItem.remoteHoverBackground
* statusBarItem.remoteHoverForeground
* statusBarItem.offlineHoverBackground
* statusBarItem.offlineHoverForeground

以下两种颜色名称已更新，因为颜色不再适用于整个状态栏，而仅适用于远程指示器：

* statusBar.offlineBackground重命名为statusBarItem.offlineBackground
* statusBar.offlineForeground重命名为statusBarItem.offlineForeground

## [粘性滚动](https://code.visualstudio.com/updates/v1_82#_sticky-scroll)

此次迭代对 Sticky Scroll UI 进行了几项改进，可以在编辑器顶部找到（视图：切换 Sticky Scroll）。

* 现在，默认情况下，当编辑器水平滚动条滚动时，粘性滚动会横向滚动。可以通过禁用 来关闭此功能 `editor.stickyScroll.scrollWithEditor` 。
* 按住 键并将鼠标悬停在 Sticky Scroll 行上，即可查看范围的最后一行Shift。按住 键并单击一行可Shift将编辑器光标移动到范围的最后一行。
* 已将折叠图标添加到 Sticky Scroll 边缘。这些图标的渲染遵循 `editor.showFoldingControls` 控制编辑器边缘中折叠图标渲染的设置。

## [差异编辑器](https://code.visualstudio.com/updates/v1_82#_diff-editor)

在此版本中，我们默认启用了新的 diff 编辑器。我们还改进了一些新的 diff 编辑器功能并修复了许多错误。

## [移动代码检测](https://code.visualstudio.com/updates/v1_82#_moved-code-detection)

本次迭代我们完善了移动代码检测功能。可以使用 `"diffEditor.experimental.showMoves": true` 或在 diff 编辑器上下文菜单中启用此功能。启用后，系统会检测同一文件中从一个位置移动到另一个位置的代码块，并绘制箭头以指示代码块移动到的位置。

代码移动在发生轻微修改时也会被检测到。可以使用比较按钮来比较移动前后的块。

## [折叠未更改的代码标题](https://code.visualstudio.com/updates/v1_82#_collapsed-unchanged-code-headers)

使用 `"diffEditor.hideUnchangedRegions.enabled": true` 或选择编辑器上下文菜单中的地图图标来折叠未改变的代码块。

在此版本中，现在有折叠代码块的面包屑导航，以指示哪些符号已折叠。单击面包屑导航项会显示所选项：

## [动态布局](https://code.visualstudio.com/updates/v1_82#_dynamic-layout)

如果 diff 编辑器的宽度太小，编辑器会自动切换到内联视图。如果编辑器再次足够宽，则会恢复以前的布局。设置 `"diffEditor.useInlineViewWhenSpaceIsLimited": false` 为禁用此行为。

## [控制终端在启动时如何恢复](https://code.visualstudio.com/updates/v1_82#_control-how-terminals-restore-on-startup)

新设置 `terminal.integrated.hideOnStartup` 控制应用程序启动时是否自动创建终端。有以下选项可用：

* never（默认）：启动时永不隐藏终端视图。
* whenEmpty：仅当没有恢复持久会话时才隐藏终端。
* always：始终隐藏终端，即使已恢复持久会话。

## [快速访问文本搜索](https://code.visualstudio.com/updates/v1_82#_quick-access-text-search)

我们正在尝试在快速访问菜单中显示工作区搜索结果。要尝试此操作，请运行搜索：快速文本搜索（实验性）。此命令设置快速打开以接受搜索查询。输入一些文本以查看来自不同工作区文件的匹配项。

## [支持批量范围格式化](https://code.visualstudio.com/updates/v1_82#_support-for-batch-range-formatting)

APIDocumentRangeFormattingEditProvider现在支持批量格式化。这意味着扩展可以选择性地向编辑器发出信号，表示它支持一次调用多个范围。这有助于减少对格式化提供程序的调用次数，从而提高性能。

要选择批量格式化，提供商必须实现一项新的可选功能：[provideDocumentRangesFormattingEdits](https://translate.google.com/website?sl=auto\&tl=zh-CN\&hl=zh-CN\&u=https://github.com/microsoft/vscode/blob/e34a26097d763548bf220da77b74922765c12fa2/src/vscode-dts/vscode.d.ts%23L4172) 。

## [监听终端命令执行](https://code.visualstudio.com/updates/v1_82#_listen-to-terminal-command-execution)

长期以来，人们一直要求扩展监听终端命令执行 API，而现在该扩展的早期提案已可供测试。此 API 是使用shell 集成实现的，并且只会在启用并运行该 API 的终端上触发。

```ts
export interface TerminalExecutedCommand {
  /**
   * The {@link Terminal} the command was executed in.
   */
  terminal: Terminal;
  /**
   * The full command line that was executed, including both the command and the arguments.
   */
  commandLine: string | undefined;
  /**
   * The current working directory that was reported by the shell. This will be a {@link Uri}
   * if the string reported by the shell can reliably be mapped to the connected machine.
   */
  cwd: Uri | string | undefined;
  /**
   * The exit code reported by the shell.
   */
  exitCode: number | undefined;
  /**
   * The output of the command when it has finished executing. This is the plain text shown in
   * the terminal buffer and does not include raw escape sequences. Depending on the shell
   * setup, this may include the command line as part of the output.
   */
  output: string | undefined;
}

export namespace window {
  /**
   * An event that is emitted when a terminal with shell integration activated has completed
   * executing a command.
   *
   * Note that this event will not fire if the executed command exits the shell, listen to
   * {@link onDidCloseTerminal} to handle that case.
   */
  export const onDidExecuteTerminalCommand: Event<TerminalExecutedCommand>;
}
```

该 API 的形式尚未最终确定，但基本思想将保持不变。

这是一个示例用法，它监听任何成功的git push命令并触发扩展中的刷新：

```ts
const disposables = [];
disposables.push(
  window.onDidExecuteTerminalCommand(command => {
    if (command.commandLine.startsWith('git push') && command.exitCode === 0) {
      refreshState();
    }
  })
);
function refreshState() {
  /* ... */
}
```

## [Electron 25 更新](https://code.visualstudio.com/updates/v1_82#_electron-25-update)

在这个里程碑中，我们正在向稳定用户推广 Electron 25 更新。此更新附带 Chromium114.0.5735.289 和 Node.js 18.15.0

---

---
url: /release_notes/q7hcc54c/index.md
---
# VSCode 1.76
> 主要内容摘抄自 [VSCode 1.76 发行说明](https://code.visualstudio.com/updates/v1_76)，文中“我们”即 VSCode

## [个人资料徽章](https://code.visualstudio.com/updates/v1_76#_profile-badge)

VS Code 现在通过在“管理活动”栏图标上将配置文件名称的前两个字母显示为配置文件徽章来指示当前自定义配置文件。

主题可以通过配置两种新的主题颜色来自定义个人资料徽章、背景和前景色：

* profileBadge.background
* profileBadge.foreground

## [Moveable Explorer 视图](https://code.visualstudio.com/updates/v1_76#_moveable-explorer-view)

VS Code 中的大多数视图和视图容器都是可移动的，但少数内置容器除外。在此版本中，资源管理器视图容器 （Ctrl+Shift+E） 现在是可移动的，并且可以放置在辅助侧边栏或底部面板中，以允许进一步的工作台自定义。

如果要将所有视图重置回默认布局，可以从命令面板运行 `Views: Reset View Locations` 。

## [在扩展编辑器中验证的发布者域](https://code.visualstudio.com/updates/v1_76#_verified-publisher-domain-in-extension-editor)

扩展编辑器现在会在已验证指示器旁边显示已验证的发布者域。

## [JSONC文档排序](https://code.visualstudio.com/updates/v1_76#_jsonc-document-sorting)

现在可以按键对 JSONC（带有注释的 JSON 文档）文件进行排序。要使用此功能，请从命令面板中选择 `JSON: Sort Document` 。

## [Git 提交语法高亮显示](https://code.visualstudio.com/updates/v1_76#_git-commit-syntax-highlighting)

VS Code 采用了新的 Git 语法，为 Git 提交消息文件提供语法高亮显示。新语法对英语以外的语言有更好的支持。

## [Markdown 工作区标题链接完成](https://code.visualstudio.com/updates/v1_76#_markdown-workspace-header-link-completions)

需要链接到另一个 Markdown 文档中的标题，但不记得或想输入完整的文件路径？尝试使用工作区标题完成！

您可以使用 Markdown > 建议 > 路径： 包括工作区标题完成设置 （  ） 来配置是否/何时显示工作区标题完成。

有效的设置值为：

* onDoubleHash（默认值）- 仅在键入 ## 后显示工作区标头完成情况。
* onSingleOrDoubleHash - 在键入 # 或 ## 后显示工作区标头完成情况。
* never - 从不显示工作区标头完成。

请记住，在当前工作区中查找所有标头的成本可能很高，因此首次请求它们时可能会有轻微的延迟，尤其是对于具有大量 Markdown 文件的工作区。

## [配置 Markdown 链接的首选文件扩展名样式](https://code.visualstudio.com/updates/v1_76#_configure-preferred-file-extension-style-for-markdown-links)

如果 VS Code 更喜欢使用文件扩展名来链接到 Markdown 文件，则会配置新的 markdown.preferredMdPathExtensionStyle 设置。此首选项用于语言工具，例如路径完成和链接重命名。

有效的设置值为：

* auto - 尝试保留文件扩展名的现有样式。
* includeExtension - 在链接中包含尾随的 .md。
* removeExtension - 从链接中删除尾随的 .md。

## [InputBox 提示和验证消息中的链接支持](https://code.visualstudio.com/updates/v1_76#_link-support-in-inputbox-prompts-and-validation-messages)

在此迭代中，我们引入了对 InputBox 提示和验证消息中链接的支持。在这些字符串中，您现在可以使用以下语法来创建链接：

```md
[link text](link target)
```

链接目标可以是 URL 或命令 ID。当用户单击链接时，链接目标将分别在浏览器中打开或作为命令执行。

Example:

```ts
const result = await vscode.window.showInputBox({
  prompt:
    'Please enter a valid email address [more info](https://aka.ms/vscode-email-validation)',
  validateInput: text => {
    if (text.indexOf('@') === -1) {
      return 'Please enter a valid email address, [more info](https://aka.ms/vscode-email-validation)';
    }
    return undefined;
  }
});
```

此行为适用于 showInputBox 和 createInputBox API。

---

---
url: /release_notes/qulgvrzg/index.md
---
# v3.1.1
## 概述

该版本主要改进了性能，并修复了在某些设备上无法进行数据同步的问题。

## 变更记录

以下是此版本中的详细变更。

### 改进功能

* [改进数据库资源字段导出](https://github.com/siyuan-note/siyuan/issues/11903)
* [改进闪卡间隔重复加载性能](https://github.com/siyuan-note/siyuan/issues/11927)
* [改进嵌入块导出](https://github.com/siyuan-note/siyuan/issues/11932)
* [改进数据库文本字段导出](https://github.com/siyuan-note/siyuan/issues/11945)
* [数据库中的资源图片支持上传到社区图床](https://github.com/siyuan-note/siyuan/issues/11948)
* [改进块引用搜索性能](https://github.com/siyuan-note/siyuan/issues/11951)
* [改进最近的文档加载性能](https://github.com/siyuan-note/siyuan/issues/11977)
* [支持搜索替换块引用锚文本](https://github.com/siyuan-note/siyuan/issues/11978)

### 修复缺陷

* [修改 `历史保留天数` 后文件历史不显示](https://github.com/siyuan-note/siyuan/issues/11935)
* [某些设备上无法进行数据同步](https://github.com/siyuan-note/siyuan/issues/11943)
* [非桌面端无法导出 Markdown](https://github.com/siyuan-note/siyuan/issues/11953)
* [标题块更新时间异常](https://github.com/siyuan-note/siyuan/issues/11985)

### 开发重构

* [升级 Electron v31.2.1](https://github.com/siyuan-note/siyuan/issues/11936)

### 开发者

* [解决 WebSocket 异步初始化问题](https://github.com/siyuan-note/siyuan/pull/11946)

---

---
url: /release_notes/rufoul0v/index.md
---
# VSCode 1.73
> 主要内容摘抄自 [VSCode 1.73 发行说明](https://code.visualstudio.com/updates/v1_73)，文中“我们”即 VSCode

## [在搜索中包含和排除文件夹](https://code.visualstudio.com/updates/v1_73#_include-and-exclude-folders-from-search)

在“搜索”视图的结果树视图中右键单击文件夹时，上下文菜单中现在有两个新选项。

* 选择“将搜索限制为文件夹”会将选定的文件夹路径添加到要包含的文件文本框中。向此文本框添加路径会将搜索结果限制为符合列出的路径或模式的结果。
* 选择“从搜索中排除文件夹”会将选定的文件夹路径添加到要排除的文件文本框中。在此处添加路径将排除任何符合列出的路径或模式的搜索结果。

## [默认折叠提供程序](https://code.visualstudio.com/updates/v1_73#_default-folding-provider)

通常，当一种语言有多个折叠提供程序处于活动状态时，VS Core 会尝试合并结果。如果存在冲突的范围，则会丢弃某些范围。此外，并非所有折叠供应商都可以与其他供应商结合使用。

新的  设置允许您选择要使用的折叠提供程序。提供程序的名称是扩展 ID （ `{publisher}.{extension}` ） 的扩展。

以下示例将（假设的）扩展 aeschli.better-folding 中的折叠提供程序设置为 JavaScript 的默认值。

```json
    "[javascript]": {
            "editor.defaultFoldingRangeProvider": "aeschli.better-folding"
    }
```

## [合并编辑器改进](https://code.visualstudio.com/updates/v1_73#_merge-editor)

## [Markdown 在文件重命名/移动时自动更新链接](https://code.visualstudio.com/updates/v1_73#_markdown-automatic-link-updates-on-file-rename-move)

厌倦了在移动或重命名文件时意外破坏 Markdown 中的链接或图像？尝试新的  设置！

您可以使用  控制受影响的文件类型。默认情况下，它对所有 Markdown 文件和常见图像文件格式都启用。

## [Markdown 未使用和重复链接定义诊断](https://code.visualstudio.com/updates/v1_73#_markdown-unused-and-duplicate-link-definition-diagnostics)

## [Markdown link occurrence highlighting](https://code.visualstudio.com/updates/v1_73#_markdown-link-occurrence-highlighting)

## [为工作空间编辑提供元数据](https://code.visualstudio.com/updates/v1_73#_provide-metadata-for-workspace-edits)

用于应用工作区编辑的 API 现在允许扩展提供元数据，例如，用于将编辑标记为重构。这些额外的元数据将被编辑器接受，并在重构后自动保存（设置：`files.refactoring.autoSave`）。

## [限制哪些命令可以由 MarkdownString 和 webviews 运行](https://code.visualstudio.com/updates/v1_73#_restrict-which-commands-can-be-run-by-markdownstring-and-in-webviews)

MarkdownString 中的命令链接是在 VS Code 的悬停消息或 IntelliSense 详细信息中创建自定义交互的有用方法。Webviews 还可以使用命令链接直接从 Webview 触发 VS Code 命令。但是，命令链接也可能很危险，因为它们可用于执行任何命令，包括许多在设计时未考虑安全性的命令。因此，默认情况下，命令链接处于禁用状态，并且必须由扩展显式启用。

虽然这种全有或全无的方法行之有效，但我们也发现它给扩展作者带来了太多的安全负担。需要使用命令链接的扩展必须验证它们呈现的内容中仅包含安全命令。这既容易忘记，也很容易出错。

为了改进这一点，我们引入了用于命令链接启用的新 API，允许扩展仅启用受信任的命令子集。

对于 MarkdownString，`isTrusted` 属性现在采用可以执行的命令的允许列表（所有其他命令都将被阻止）：

```ts
const md = new vscode.MarkdownString(
  `A command link: [Open setting](command:workbench.action.openSettings)`
);

// Set trusted commands instead of enabling all commands
md.isTrusted = { enabledCommands: ['workbench.action.openSettings'] };
```

对于 Webview，`WebviewOptions.enableCommandUris` 属性现在可以是已启用命令的列表，而不是简单的 true/false：

```ts
const options: vscode.WebviewOptions = {
  enableCommandUris: ['workbench.action.openSettings']
};
```

我们强烈建议所有使用命令链接的扩展都采用这种新的、限制性更强的 API，以提高安全性。

## [Web 视图和 WebView 视图的一致源](https://code.visualstudio.com/updates/v1_73#_consistent-origin-for-webviews-and-webview-views)

为了缩短 Web 视图的加载时间，我们现在尝试为给定类型的 Web 视图的所有实例保持一致的来源。这有两个主要好处：

* Web视图可以更好地利用缓存。这意味着本地资源的加载速度应该更快。
* Web视图可以使用本地存储和其他按源分区的 Web API。
  请记住，webview 的所有实例现在都将在同一源上运行，因此，如果它们使用 API（如本地存储），请确保对每个资源特定于文档的任何数据/状态进行分区。例如，`localStorage.setItem('scrollPosition', 100)` 将在所有 webview 实例中将 `scrollPosition` 设置为 100。如果要设置单个资源的滚动位置，还需要在键中包含资源 ID：`localStorage.setItem(myDocUri, JSON.stringify({scrollPosition: 100 }))` 。
  您也不应使用 localStorage 或类似的 API 来存储关键数据，例如文档内容。虽然 VS Code 尽最大努力维护 Web 视图的一致源，但我们不能保证源不会更改。
  在许多情况下，您应该使用 [webview 状态 API](https://code.visualstudio.com/api/extension-guides/webview#getstate-and-setstate) ，因为这些 API 可以为您处理上述两个问题。

源是为每个扩展和 webview 类型随机生成的。在 WebView 的所有实例中使用相同的源。

目前，普通的 Web 视图和 WebView 视图都试图保持一致的来源。我们计划在下一次迭代中将此功能用于自定义编辑器和笔记本 Web视图。

## [日志输出通道](https://code.visualstudio.com/updates/v1_73#_log-output-channel)

在上一个里程碑中，我们引入了 LogOutputChannel API 提案，用于创建仅用于日志记录的输出通道。在此迭代中，我们向其添加了 logLevel 属性和 onDidChangeLogLevel 事件。logLevel 属性表示输出通道的当前日志级别，当输出通道的日志级别发生变化时，将触发 onDidChangeLogLevel 事件。

```ts
/**
 * A channel for containing log output.
 */
export interface LogOutputChannel extends OutputChannel {

    /**
     * The current log level of the channel.
     * Defaults to application {@link env.logLevel application log level}.
     */
    readonly logLevel: LogLevel;

    /**
     * An {@link Event} which fires when the log level of the channel changes.
     */
    readonly onDidChangeLogLevel: Event<LogLevel>;
    ...
    ...
}
```

我们还向 env 命名空间添加了 logLevel 属性和 onDidChangeLogLevel 事件，以表示应用程序的当前日志级别，当应用程序的日志级别发生变化时，将触发该事件。

```ts
export namespace env {
  /**
   * The current log level of the application.
   */
  export const logLevel: LogLevel;

  /**
   * An {@link Event} which fires when the log level of the application changes.
   */
  export const onDidChangeLogLevel: Event<LogLevel>;
}
```

## [优化输入延迟](https://code.visualstudio.com/updates/v1_73#_optimizing-for-input-latency)

随着 VS Code 的大小不断增大，按下击键时的活动量也在增加。在这次迭代中，我们退后一步，对在编辑器中输入时究竟会发生什么进行了彻底的调查，以及我们可以将什么推迟到击键在屏幕上呈现之后。此次勘探的主要成果是：

* 进行了几项更改，以尽可能地推迟工作，直到编辑器中的击键在屏幕上呈现之后。对此影响的粗略估计是，当 IntelliSense 未显示时，输入延迟会减少 ~15%，而当 IntelliSense 正在重新筛选时，输入延迟的减少甚至更高。
* 现在，我们拥有更精细的技术，可以手动测量输入延迟，并在这个亚毫秒\*级别进行优化。
* 有一项正在进行的更改将帮助我们跟踪和报告输入延迟的样本。这将为我们提供一些具体的数字来维持和改进。

这只是这项工作的开始，我们还有更多更改应该会在下一个版本发布。

\* *这些数字很大程度上取决于用于测试的硬件。在功能强大的硬件上，0.5 毫秒的改进可能最终在更普通的硬件上变成 2 毫秒。*

---

---
url: /release_notes/s4zo6xdj/index.md
---
# VSCode 1.70
> 主要内容摘抄自 [VSCode 1.70 发行说明](https://code.visualstudio.com/updates/v1_70)，文中“我们”即 VSCode

## [树查找控件](https://code.visualstudio.com/updates/v1_70#_tree-find-control)

树视图（如文件资源管理器）现在支持“查找”控件。您可以在树内按 `Ctrl+Alt+F` 以弹出“查找”控件。您可以使用“查找”控件来突出显示匹配的元素，或切换“筛选器”按钮来隐藏与搜索词不匹配的所有元素。

## [编辑器粘性滚动](https://code.visualstudio.com/updates/v1_70#_editor-sticky-scroll)

现在可以显示 UI，显示用户在滚动期间所处的范围。“粘性滚动”UI 将显示编辑器顶部位于哪个类/接口/命名空间/函数/方法/构造函数中，帮助您了解文档中的位置。使用 `editor.experimental.stickyScroll.enabled` 设置启用粘滞滚动。

## [htmlLanguageParticipants贡献点](https://code.visualstudio.com/updates/v1_70#_htmllanguageparticipants-contribution-point)

一个新的贡献点 `htmlLanguageParticipants` 允许类 HTML 语言声明他们想要继承所有 HTML 语言服务器特性，例如代码完成、悬停和大纲。这对于不想实现完整语言服务器的编程语言扩展很有用。

一个例子是内置的 handlebars 扩展，它现在在其package.json中将自身添加到 htmlLanguageParticipants：

```json
"contributes": {
  "htmlLanguageParticipants": [
     {
       "languageId": "handlebars"
      }
    ]
}
```

[Quarkus](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus) 扩展已经采用了贡献点。它通过针对嵌入式 Qute HTML 模板语言的附加建议丰富了 HTML 功能

## [Webview 上下文菜单](https://code.visualstudio.com/updates/v1_70#_webview-context-menus)

---

---
url: /release_notes/s4zwfodm/index.md
---
# VSCode 1.85 (2023 年 11 月)
> 主要内容摘抄自 [VSCode 1.85 发行说明](https://code.visualstudio.com/updates/v1_85)，文中“我们”即 VSCode

## [浮动编辑器窗口](https://code.visualstudio.com/updates/v1_85#_floating-editor-windows)

我们很高兴地宣布，在此版本中，您可以将编辑器从主窗口移动到他们自己的轻量级窗口。在一个窗口中对编辑器所做的更改会立即应用于编辑器打开的所有其他窗口。

创建浮动编辑器窗口的最简单方法是将编辑器拖出当前窗口，然后将其拖放到桌面上的空白区域。

新的  设置可以禁用此行为。

此外，还有一些新的全局和上下文命令，用于将编辑器和编辑器组移动或复制到其自己的窗口中：

* View: Copy Editor into New Window (workbench.action.editor.copyWithSyntaxHighlightingAction)
* View: Move Editor into New Window (workbench.action.editor.moveEditorToNextWindow)
* View: Copy Editor Group into New Window (workbench.action.editor.copyGroupToNextWindow)
* View: Move Editor Group into New Window (workbench.action.editor.moveGroupToNextWindow)
* View: New Empty Editor Window (workbench.action.newWindow)

浮动窗口中的编辑器区域可以按照您想要的任何[复杂布局](http://code.visualstudio.com/docs/editor/custom-layout)进行排列。而且，由于终端和搜索结果都可以作为编辑器打开，因此您现在也可以在单独的窗口中拥有这些功能！

## [文件资源管理器中的本机粘贴支持](https://code.visualstudio.com/updates/v1_85#_native-paste-support-in-the-file-explorer)

VS Code 现在支持将操作系统资源管理器中的文件本机粘贴到 VS Code 文件资源管理器中。

## [扩展自动更新控制](https://code.visualstudio.com/updates/v1_85#_extension-auto-update-control)

您现在可以选择要自动更新的扩展程序。如果您不想自动更新所有扩展，而是有选择地选择要自动更新的扩展，这将非常有用。您可以选择一个扩展，也可以选择发布者中的所有扩展。如果您选择自动更新发布商的所有扩展程序，则可以取消选择该发布商的单个扩展程序。

您应已禁用自动更新（无）或启用所选扩展程序（所选扩展程序）才能使用此功能。

## [设置编辑器搜索改进和 bug 修复](https://code.visualstudio.com/updates/v1_85#_settings-editor-search-improvements-and-bug-fixes)

“设置”编辑器又回到了首先按匹配类型对搜索结果进行排序，而不仅仅是按目录排序。换言之，标题和关键字匹配项会显示在顶部，因此您无需向下滚动即可找到具有匹配标题的设置。

“设置”编辑器仍按目录对设置进行排序，这意味着在搜索查询（如 `@ext：<extension-id>`）时，将遵循扩展作者的顺序键。

此迭代还修复了许多设置编辑器回归问题，包括由于网络问题导致设置编辑器无法加载，以及在某些搜索查询上挂起。

## [多文档高亮显示](https://code.visualstudio.com/updates/v1_85#_multi-document-highlighting)

多文档高亮显示得到了新提议的 [MultiDocumentHighlightProvider](https://code.visualstudio.com/updates/v1_85#_multi-document-highlighting-api) API 的额外支持。现在，内置了对 TypeScript 语言的语义出现高亮显示的支持，可以通过将 Editor： Occurrences Highlight （editor.occurrencesHighlight） 设置值从 singleFile 更改为 multiFile 来启用。对于除 TypeScript 以外的语言，在实现更多特定于语言的提供程序之前，多文档匹配项将根据文本匹配项而不是语义匹配项突出显示。

## [传入/传出更改](https://code.visualstudio.com/updates/v1_85#_incomingoutgoing-changes)

在这个里程碑中，我们在源代码管理视图中引入了一个新的传入/传出部分，以显示当前分支与其远程分支相比的传入和传出更改。新部分既显示单个更改（更改的资源数量以及插入和删除），还显示汇总所有更改中所有资源的“所有更改”条目。可以使用  和  设置来控制新部分的可见性。这两个设置都支持以下值：always、auto（默认）和 never。

## [输入最大行数](https://code.visualstudio.com/updates/v1_85#_input-maximum-lines)

以前，源代码管理输入会自动增长，最多显示 6 行文本，这对于大多数提交消息来说已经足够了。但是，在某些情况下，更多空间会有所帮助，并且有一个新设置  ，用于控制源代码管理输入行的最大数量。

## [终端粘性滚动]()

视口顶部的命令提示符会粘在终端的顶部，类似于 Sticky Scroll 在编辑器中的工作方式。单击 Sticky Scroll 元素将滚动到终端缓冲区的该部分。此功能目前默认处于禁用状态，但可以通过设置  为 `true` 来启用。我们计划在未来默认启用此功能，届时您将能够通过右键单击并关闭它来选择退出。

## [TS首选使用“type”进行自动导入](https://code.visualstudio.com/updates/v1_85#_prefer-using-type-for-auto-imports)

仅类型导入允许您导入类型，同时确保导入在运行时被完全擦除。如果您更喜欢始终默认输入，您现在可以设置 为 `true` ，自动导入将使用仅类型导入。默认情况下，此设置处于关闭状态。

## [树上的粘性滚动](https://code.visualstudio.com/updates/v1_85#_sticky-scroll-in-trees)

在编辑器中 Sticky Scroll 成功的基础上，我们将此功能扩展到所有树视图，使用户能够更轻松地浏览项目树。可以通过设置  为 `true` 来启用树的粘性滚动。为确保 Sticky Scroll 不会占用太多空间，它最多只能占用视图高度的 40%。此外，用户可以通过配置 （默认设置为 7）来自定义粘性元素的最大数量。

为了改进树导航体验，您可以选择一个粘性元素以直接跳转到树中的它，或者按父元素的 V 形图标以隐藏其所有子元素。此外，启用粘滞滚动后，访问复选框和操作项更容易。

## [多文件差异编辑器](https://code.visualstudio.com/updates/v1_85#_multifile-diff-editor)

此版本提供了多重差异编辑器的预览版。多重差异编辑器允许您在一个可滚动视图中查看多个文件中的更改：

要启用多重差异编辑器，请设置 `"multiDiffEditor.experimental.enabled": true` 。目前，multi diff 编辑器可用于查看本地更改、暂存更改、传入/传出更改以及拉取请求的更改。请注意，多重差异编辑器的功能尚未完成，可能并非在所有情况下都有效。

## [多文档高亮 API](https://code.visualstudio.com/updates/v1_85#_multi-document-highlighting-api)

如上一版本中介绍的那样，现在支持 VS Code 中的多文档高亮显示。在此迭代中，我们添加了[一个建议的 MultiDocumentHighlightProvider API](https://github.com/microsoft/vscode/blob/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts) ，用于注册多文档突出显示提供程序。这增加了为特定编程语言提供语义出现高亮显示的能力。提供程序返回一个新的 MultiDocumentHighlight 结构，其中包含 URI 到 DocumentHighlight 的映射。

---

---
url: /release_notes/sc04pglt/index.md
---
# VSCode 1.99 (2025 年 3 月)
> 主要内容摘抄自 [VSCode 1.99 发行说明](https://vscode.js.cn/updates/v1_99)，文中“我们”即 VSCode

## [内联建议语法高亮](https://vscode.js.cn/updates/v1_99#_inline-suggestion-syntax-highlighting)

通过此更新，内联建议的语法高亮现在默认启用。如果您喜欢没有语法高亮的内联建议，您可以使用   禁用它。

---

---
url: /release_notes/slw02re0/index.md
---
# VSCode 1.80
> 主要内容摘抄自 [VSCode 1.80 发行说明](https://code.visualstudio.com/updates/v1_80)，文中“我们”即 VSCode

## \[控制固定宽度标签的最小宽度]

当  设置为 fixed 时，新设置  控制选项卡的最小大小。[1.79 发行说明](https://code.visualstudio.com/updates/v1_79#_new-tab-sizing-option-fixed)中更详细地解释了固定的选项卡宽度。

## [搜索 .gitignore exclude 行为](https://code.visualstudio.com/updates/v1_80#_search-gitignore-exclude-behavior)

当  设置为 true 时，无论工作区是否初始化为 Git 存储库，现在都会尊重工作区的 `.gitignore` 。

## [可调整大小的内容悬停](https://code.visualstudio.com/updates/v1_80#_resizable-content-hover)

现在可以调整内容悬停控件的大小。您可以将鼠标悬停在控制边框上，然后拖动窗框以更改悬停的大小。

## [关闭存储库改进](https://code.visualstudio.com/updates/v1_80#_close-repository-improvements)

过去，用户可以在源代码管理视图中使用 `Git: Close Repository` 命令或 Close Repository 操作来关闭存储库，但某些操作（例如，从已关闭的存储库中打开文件）会重新打开已关闭的存储库。在这个里程碑上，我们进行了一些改进，因此现在每个工作区都会保留仓库已关闭的事实。用户可以使用 `Git: Reopen Closed Repositories` 命令重新打开已关闭的仓库。

## [Markdown 格式化粘贴的 URL 作为 Markdown 链接](https://code.visualstudio.com/updates/v1_80#_markdown-format-pasted-urls-as-markdown-links)

新的  设置（默认为 false）允许您在 Markdown 编辑器中插入自动格式化为 Markdown 链接的链接。如果您选择一些文本以替换为粘贴的链接，则所选文本将自动成为链接的标题。如果未选择任何文本，则将有一个默认的链接标题。此功能适用于外部浏览器链接以及工作区中的文件。

您必须启用设置  才能使此新设置生效。

## [树形复选框 API](https://code.visualstudio.com/updates/v1_80#_tree-checkbox-api)

TreeItem checkboxState API 已完成。默认情况下，具有复选框的树项将由 VS Code 管理其选中状态。可以通过将 TreeViewOptions 属性 manageCheckboxStateManually 设置为 true 来更改此行为。设置 manageCheckboxStateManually 后，扩展负责管理父复选框和子复选框的选中和取消选中。

## [EnvironmentVariableCollection.description](https://code.visualstudio.com/updates/v1_80#_environmentvariablecollectiondescription)

这个新的 API 允许为 EnvironmentVariableCollection 指定描述，在终端选项卡悬停中向用户显示，以解释更改到底在做什么。

```ts
// Example of what the Git extension could use
context.environmentVariableCollection.description =
  'An explanation of what the environment changes do';
```

## [文件系统提供程序的只读消息](https://code.visualstudio.com/updates/v1_80#_readonly-message-for-file-system-providers)

当您注册FileSystemProvider时，您可以提供只读消息，而不是简单地将文件系统标记为只读。当用户尝试编辑来自该提供商的文件时，以下消息将显示在编辑器中。

---

---
url: /release_notes/tos7vcrs/index.md
---
# VSCode 1.96 (2024 年 11 月)
> 主要内容摘抄自 [VSCode 1.96 发行说明](https://vscode.js.cn/updates/v1_96)，文中“我们”即 VSCode

## [改进的扩展搜索结果](https://vscode.js.cn/updates/v1_96#_improved-extension-search-results)

当您在“扩展”视图中使用自由格式文本搜索扩展时，已安装的扩展现在会显示在搜索结果的顶部。这使得在搜索 Marketplace 时更容易查找和管理已安装的扩展。

## [扩展磁盘空间](https://vscode.js.cn/updates/v1_96#_extension-disk-space)

您现在可以在“扩展”编辑器中查看扩展在磁盘上的内存使用情况。这可以帮助您了解扩展正在使用多少磁盘空间。

## [配置允许的扩展](https://vscode.js.cn/updates/v1_96#_configure-allowed-extensions)

您现在可以使用  设置控制哪些扩展可以在 VS Code 中安装。此设置允许您按发布者、特定扩展和版本指定允许或阻止的扩展。如果扩展或版本被阻止，则如果已安装，它将被禁用。您可以指定以下类型的扩展选择器：

* 允许或阻止来自发布者的所有扩展
* 允许或阻止特定扩展
* 允许特定扩展版本
* 允许特定扩展版本和平台
* 只允许扩展的稳定版本
* 只允许发布者的稳定扩展版本

---

---
url: /release_notes/uh7jhtu6/index.md
---
# VSCode 1.88 (2024 年 3 月)
> 主要内容摘抄自 [VSCode 1.88 发行说明](https://code.visualstudio.com/updates/v1_88)，文中“我们”即 VSCode

## [开放编辑器的自定义标签](https://code.visualstudio.com/updates/v1_88#_custom-labels-for-open-editors)

现在，您可以自定义编辑器选项卡和打开编辑器视图的显示标签。此功能可用于区分同名文件的编辑器。

您可以通过在 `workbench.editor.customLabels.patterns` 设置下添加条目来根据自己的喜好定制这些标签。每个条目都应包含一个与文件路径匹配的glob 模式和一个定义编辑器选项卡新名称的模板。此自定义仅在文件路径与指定模式匹配时适用。模式是否匹配取决于它被定义为相对还是绝对文件路径模式。

模板可以包含诸如 `${filename}` 和 `${extname}` 之类的变量，这些变量可以用文件路径中的值动态替换。`${dirname}${dirname(N)}`

要启用或禁用这些自定义标签，请使用 `workbench.editor.customLabels.enabled` 设置。这样您就可以随时切换到原始编辑器名称，而无需删除自定义模式。

## [锁定滚动](https://code.visualstudio.com/updates/v1_88#_locked-scrolling)

现在，您可以使用 **`View: Toggle Locked Scrolling Across Editors`** 命令同步所有可见编辑器的滚动。这意味着，当您在一个编辑器中滚动时，所有其他编辑器都会滚动相同的量，从而保持所有内容对齐。如果您需要并排比较文件，此功能非常有用。

如果您想要更好地控制启用和禁用锁定滚动，您可以选择仅在按住特定键时激活滚动同步。为命令设置键盘快捷键 `workbench.action.holdLockedScrolling` ，您就可以在需要时临时锁定编辑器中的滚动。

## [底部的活动栏](https://code.visualstudio.com/updates/v1_88#_activity-bar-at-the-bottom)

之前，我们引入了将活动栏移至侧边栏顶部的选项。现在，我们还允许您将活动栏移至底部。为此，请将设置更改 `workbench.activityBar.location` 为 `bottom` 。

```josn
"workbench.activityBar.location": "bottom"
```

我们还改进了活动栏位于顶部时的外观和感觉，以确保它与界面的其余部分很好地契合。

## [重启扩展](https://code.visualstudio.com/updates/v1_88#_restart-extensions)

当扩展更新时，您现在可以重新启动扩展，而不必重新加载窗口。

## [小地图部分标题](https://code.visualstudio.com/updates/v1_88#_minimap-section-headers)

小地图现在可以识别和呈现由折叠标记定义的部分（例如 `//#region Deletion` 中的部分）, 这让您可以快速扫描和浏览大型文件。

## [差异编辑器阶段/恢复选择按钮](https://code.visualstudio.com/updates/v1_88#_diff-editor-stagerevert-selection-buttons)

差异编辑器现在有单独的Stage和Revert控件边框。这些操作可让您暂存或还原已更改的代码块。

如果您对文本进行了某些更改的选择，这些按钮可以让您暂停或恢复所选的更改（选择范围内的所有更改的字符）。

\==截至版本 1.92 ，VSCode 差异编辑器对区块的识别没有 Souretree 那么细致=={.danger}

## [传入更改文件装饰](https://code.visualstudio.com/updates/v1_88#_incoming-changes-file-decorations)

为了避免在从远程合并/重新定基更改时发生潜在冲突，我们现在会显示所有有传入更改且已获取但尚未合并/重新定基的文件的文件修饰。要使用此功能，您应该同时启用 `git.autofetch` 和 `git.decorations.enabled` 设置。

## [在 Markdown 中更智能地插入图像和链接](https://code.visualstudio.com/updates/v1_88#_smarter-inserting-of-images-and-links-in-markdown)

当您将图像或文件拖放或粘贴到 Markdown 文件中时，VS Code 会自动为其插入 Markdown 图像或链接语法。当您插入到不支持 Markdown 语法的代码块和其他上下文中时，我们现在还会智能地禁用此行为.

您随时可以使用拖放/粘贴小部件切换回插入 Markdown 语法。您可以使用 `markdown.editor.drop.enabled` 和 `markdown.editor.filePaste.enabled` 设置来配置此行为。

## [本地工作区扩展](https://code.visualstudio.com/updates/v1_88#_local-workspace-extensions)

我们很高兴推出这项新的预览功能，它允许您直接在工作区中打包扩展。此功能旨在满足您特定的工作区需求并提供更量身定制的开发体验。

要使用此功能，您需要将扩展​​打包到.vscode/extensions工作区内的文件夹中。然后，VS Code 会在扩展​​视图的工作区推荐部分中显示此扩展，用户可以从中安装它。VS Code 仅为该工作区安装此扩展。它还要求用户在安装和运行此扩展之前信任该工作区。

## [终端 shell 集成 API](https://code.visualstudio.com/updates/v1_88#_terminal-shell-integration-api)

现已推出一种新提议的 API，它允许访问由 shell 集成激活的终端提供的一些信息。使用此 API，可以监听终端中正在执行的命令的传入数据和退出代码。它还引入了一种更可靠的方法来执行命令，即在发送命令之前等待提示符可用，这有助于解决各种 shell 设置中可能出现的一些冲突/竞争条件。

以下是使用该Terminal.shellIntegration.executeCommand提案的一个例子：

```ts
// Execute a command in a terminal immediately after being created
const myTerm = window.createTerminal();
window.onDidActivateTerminalShellIntegration(async ({ terminal, shellIntegration }) => {
  if (terminal === myTerm) {
    const command = shellIntegration.executeCommand('echo "Hello world"');
    const code = await command.exitCode;
    console.log(`Command exited with code ${code}`);
  }
}));

// Fallback to sendText if there is no shell integration within 3 seconds of launching
setTimeout(() => {
  if (!myTerm.shellIntegration) {
    myTerm.sendText('echo "Hello world"');
    // Without shell integration, we can't know when the command has finished or what the
    // exit code was.
  }
}, 3000);
```

下面是一个监听命令数据流的例子：

```ts
// Create a terminal and log all data via console.log
const myTerm = window.createTerminal();
window.onDidStartTerminalShellExecution(execution => {
  if (execution.terminal === myTerm) {
    const stream = execution.createDataStream();
    for await (const data of stream) {
      console.log(data);
    }
  }
});
```

[您可以在此处](https://translate.google.com/website?sl=auto\&tl=zh-CN\&hl=zh-CN\&u=https://github.com/microsoft/vscode/blob/main/src/vscode-dts/vscode.proposed.terminalShellIntegration.d.ts)查看新的 API 。

---

---
url: /release_notes/wygxat9t/index.md
---
# VSCode 1.90 (2024 年 5 月)
> 主要内容摘抄自 [VSCode 1.90 发行说明](https://code.visualstudio.com/updates/v1_90)，文中“我们”即 VSCode

## [编辑器选项卡多​​选](https://code.visualstudio.com/updates/v1_90#_editor-tabs-multi-select)

您现在可以同时选择多个选项卡，从而可以一次将操作应用于多个编辑器。此新功能使您可以通过单个操作移动、固定或关闭多个选项卡。要将另一个选项卡添加到您的选择中，请使用Ctrl + Click（Cmd + Click在 macOS 上）。要选择一系列选项卡，请使用Shift + Click。

## [⚠️ 删除画布渲染器](https://code.visualstudio.com/updates/v1_90#_-removal-of-the-canvas-renderer)

画布渲染器在 VS Code 1.89 版本中已弃用，现已完全删除。这意味着在少数不支持 WebGL2 的机器上，终端现在使用基于 DOM 的渲染器。

## [VS Code 原生的 PowerShell IntelliSense](https://code.visualstudio.com/updates/v1_90#_vs-codenative-intellisense-for-powershell)

除了几项可靠性改进之外，我们还对终端中的 PowerShell IntelliSense 进行了以下更改：

* `terminal.integrated.shellIntegration.suggestEnabled` 已更改为 `terminal.integrated.suggest.enabled`
* 新的 `terminal.integrated.suggest.quickSuggestions` 控制功能会在您在空格后输入时是否显示建议
* 新的 `terminal.integrated.suggest.suggestOnTriggerCharacters` 控制是否在您输入时显示建议 `/`，`\` 或`-`

## [使用 esbuild 进行扩展开发](https://code.visualstudio.com/updates/v1_90#_use-esbuild-for-extensions)

TypeScript和Web的yo代码扩充生成器现在可以选择使用esbuild作为捆绑器。当您选择esbuild时，这将创建一个esbuild.js构建脚本并在pack.json中添加脚本条目并在.vscode/task.json中添加构建任务。要在现有扩展中使用esbuild，请查看[捆绑扩展](https://code-visualstudio-com.translate.goog/api/working-with-extensions/bundling-extension?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN)和[Web 扩展](https://code-visualstudio-com.translate.goog/api/extension-guides/web-extensions?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN)指南。

您可以在 [vscode-extension-samples/esbuild-sample](https://translate.google.com/website?sl=auto\&tl=zh-CN\&hl=zh-CN\&u=https://github.com/microsoft/vscode-extension-samples/tree/main/esbuild-sample) 找到示例项目。

## [Electron 29 更新](https://code.visualstudio.com/updates/v1_90#_electron-29-update)

在这个里程碑中，我们在稳定版本上向用户推广 Electron 29 更新。此更新附带 Chromium 122.0.6261.156 和 Node.js 20.9.0

---

---
url: /release_notes/y233f73d/index.md
---
# VSCode 1.81
> 主要内容摘抄自 [VSCode 1.81 发行说明](https://code.visualstudio.com/updates/v1_81)，文中“我们”即 VSCode

## [Markdown 将 URL 粘贴为格式化链接](https://code.visualstudio.com/updates/v1_81#_markdown-paste-urls-as-formatted-links)

&#x20;设置现在有一个新的 `smart` 选项。智能粘贴功能可以检测您何时粘贴到您可能不希望自动 Markdown 链接格式化的文本中。智能粘贴忽略的一些情况包括在 Markdown 链接内粘贴、粘贴到另一个 Markdown 链接上以及代码块内粘贴。

默认情况下，pasteUrlAsFormattedLink 功能当前处于关闭状态（ `never` ），但您可以将设置更改为 `smart` 或 `always`（始终创建格式化的 URL 链接）。

## [revealSetting 和 focusSearch 已添加到 IOpenSettingsActionOptions 中](https://code.visualstudio.com/updates/v1_81#_revealsetting-and-focussearch-added-to-iopensettingsactionoptions)

扩展现在可以将 revealSetting 对象和 focusSearch 布尔值传递到接受 IOpenSettingsActionOptions 参数的命令中，例如 `workbench.action.openSettingsJson` 。

例如，以下命令

```ts
vscode.commands.executeCommand('workbench.action.openSettingsJson', {
  revealSetting: { key: 'editor.renderWhitespace' }
});
```

打开用户设置 JSON 文件，然后显示 `editor.renderWhitespace` 设置（如果存在）。

## [QuickPickItem 中的图标已完成](https://code.visualstudio.com/updates/v1_81#_icons-in-quickpickitem-finalized)

QuickPickItem 中用于图标的 API 已完成。现在，可以使用 iconPath 属性在 QuickPickItem中显示图标。

---

---
url: /release_notes/youxw81k/index.md
---
# VSCode 1.92 (2024 年 7 月)
> 主要内容摘抄自 [VSCode 1.92 发行说明](https://code.visualstudio.com/updates/v1_92)，文中“我们”即 VSCode

## [将面板移至顶部](https://code.visualstudio.com/updates/v1_92#_move-panel-to-top)

您现在可以将面板移至工作平台的顶部，在编辑器区域之上。默认情况下，面板位于底部，包括诸如终端、输出面板和调试控制台等视图。此增强功能补充了现有的将面板定位在左侧、右侧和底部的选项。

## [配置文件编辑器预览](https://code.visualstudio.com/updates/v1_92#_profiles-editor-preview)

在这个里程碑中，我们继续改进配置文件编辑器，使其更易于使用，并具有与设置编辑器一致的外观和感觉。配置文件编辑器作为一项实验性功能，可通过 `workbench.experimental.enableNewProfilesUI`设置启用 (since 1.91) 。启用后，您可以从窗口左下角的设置齿轮图标访问配置文件编辑器。

## [覆盖现有配置文件](https://code.visualstudio.com/updates/v1_92#_override-existing-profile)

现在，您可以通过创建具有相同名称的新配置文件来覆盖现有配置文件，包括默认配置文件。

## [改进的扩展更新体验](https://code.visualstudio.com/updates/v1_92#_improved-extension-update-experience)

我们对扩展更新体验进行了几处改进，让您对更新扩展有更多的控制，并更易于管理扩展的自动更新。

> 所有扩展的自动更新

我们在扩展视图标题区域更改了全局扩展自动更新操作，变为“为所有扩展启用自动更新”和“为所有扩展禁用自动更新”操作。通过这些操作，您可以一次性启用或禁用所有扩展的自动更新。

> 单个扩展的自动更新

我们改进了单个扩展的自动更新体验，始终显示启用或禁用扩展自动更新的操作。这使扩展的自动更新管理更加容易。

> 通过 VSIX 安装的扩展禁用自动更新

当您通过 VSIX 安装扩展时，默认情况下该扩展的自动更新被禁用。这使您能够使用已安装的扩展版本，而不会自动更新。

> 对扩展更新的更多控制

当您将一个没有可执行代码的已安装扩展版本更新为具有可执行代码的版本时，现在需要用户同意。这使您能够在应用此类更新之前对其进行审查。
选择“审查”按钮会在浏览器中打开扩展更改日志或扩展存储库。您可以审查更改，然后决定是否要更新扩展。

## [设置编辑器跳转问题已修复](https://code.visualstudio.com/updates/v1_92#_settings-editor-jump-issue-fixed)

过去，设置编辑器在修改设置后会跳转，并将焦点更改到另一个设置。而且在修改设置之前滚动得越多，这种跳转情况就越糟。我们更改了设置编辑器在修改设置后重新渲染设置的方式，现在设置编辑器在修改设置后不再跳转。

## [设置的 URL 处理](https://code.visualstudio.com/updates/v1_92#_url-handling-for-settings)

VS Code 现在可以处理格式为 vscode://settings/setting.name 的“设置”URL（对于 Insiders 版本是 vscode-insiders://settings/setting.name ，对于 OSS 版本是 code-oss），并将打开设置编辑器到指定的设置。如果没有给出设置，则仍会打开设置编辑器。当在发行说明中使用带有设置 URL 的锚标签，并且在 VS Code 中打开发行说明时，我们会按照之前的代码设置功能进行特殊处理和渲染。

## [配置用于打开链接的浏览器](https://code.visualstudio.com/updates/v1_92#_configure-the-browser-to-open-links)

一个新的设置 `workbench.externalBrowser` 使您能够配置用于打开链接的浏览器。默认情况下，使用操作系统的标准浏览器。您可以在每个工作区级别配置此设置，并且此设置也支持设置同步。
将浏览器可执行文件的完整路径指定为设置值。或者，为了确保在不同设备上的正确功能，您还可以使用浏览器别名，例如 edge、chrome 或 firefox 。

## [禁用拖放时自动打开文件](https://code.visualstudio.com/updates/v1_92#_disable-auto-file-open-on-drag-and-drop)

以前，将文件拖放到资源管理器中也会自动在编辑器中打开它。在某些情况下，这可能不是期望的行为。一个新的设置 `explorer.autoOpenDroppedFile` 使您能够切换此行为。默认情况下，拖放文件时会继续在编辑器中打开，但设置为 false 时，此行为将被禁用。

## [灯泡控件的改进](https://code.visualstudio.com/updates/v1_92#_lightbulb-control-improvements)

有时，灯泡控件可能会遮挡编辑器中的代码。为了解决这个问题，我们为灯泡控件引入了一种改进的启发式方法，当没有空间时，会在编辑器的侧边栏显示灯泡，而不是遮挡编辑器中的代码。
您可以使用  设置在编辑器中切换灯泡控件。

## [传入/传出更改图](https://code.visualstudio.com/updates/v1_92#_incomingoutgoing-changes-graph)

在这个里程碑中，我们使用一个图来实现传入和传出更改的可视化。该图包含当前分支、当前分支的上游分支以及一个可选的基础分支。该图的根是这些分支的共同祖先。

我们对历史项悬停进行了几项改进：

* 启用了多选，以查看属于同一分支的多个历史项的更改。
* 在“...”菜单中添加了选项，以从远程/基础分支过滤历史项。
* 添加了获取、拉取和推送历史项的操作。

您可以通过切换 `scm.showHistoryGraph` 设置来禁用传入/传出更改的图形可视化。

## [终端外壳集成](https://code.visualstudio.com/updates/v1_92#_terminal-shell-integration)

每次源控制操作以及针对特定文件/文件夹的文件系统事件之后，源控制视图都会刷新。当在集成终端中执行 git 命令时，命令完成与源控制视图刷新之间可能会有延迟。为了减少这种延迟，从这个里程碑开始，我们使用终端外壳集成 API 来检测在集成终端中执行的各种 git 命令（例如，添加、签出、提交、获取、拉取、推送等）的成功完成，并刷新源控制视图。

## [Notebook 多单元格注释](https://code.visualstudio.com/updates/v1_92#_multicell-commenting)

笔记本编辑器现在支持一次对一个或多个单元格切换注释。通过选择一个或多个单元格容器，然后使用键盘快捷键 Ctrl+/ 来实现。

## [粘贴时更新 Markdown 链接](https://code.visualstudio.com/updates/v1_92#_update-markdown-links-on-paste)

> since 1.89

VS Code 现在可以通过更新任何复制和粘贴文本中的链接，帮助您在 Markdown 文档之间移动文本部分。有了这个功能，VS Code 会修复所有相对路径链接、引用链接以及所有具有相对路径的图像/视频，以便它们在新文档中正常工作。
每当您在两个 Markdown 文件之间复制和粘贴带有链接的文本时，此功能就会启动。如果有可以更新的链接，粘贴后您将看到粘贴小部件。选择“粘贴并更新粘贴的链接”，VS Code 会为您修复链接。
您可以通过将 `markdown.editor.updateLinksOnPaste.enabled` 设置为 false 来完全禁用此功能。

## [使用 python-environment-tools 改进 Python 发现](https://code.visualstudio.com/updates/v1_92#_improved-python-discovery-using-pythonenvironmenttools)

在上一版本中，我们宣布了 Python 环境工具，它重新设计了专注于性能的 Python 发现基础设施。这种方法减少了执行 Python 二进制文件以探测信息的需求，从而提高了性能。
从本版本开始，我们将此增强功能作为实验的一部分推出。如果您有兴趣尝试，可以在用户设置的 settings.json 中将 "python.locator" 设置为 "native" ，然后重新加载 VS Code 窗口。

## [Python 源代码中的内联变量值](https://code.visualstudio.com/updates/v1_92#_inline-variable-values-in-source-code)

Python 调试器扩展引入了内联值功能，以增强您的 Python 调试体验。使用内联值，您可以在调试会话期间在编辑器中内联查看变量的值，就在相应的代码行旁边。这有助于您快速了解程序的状态，而无需将鼠标悬停在变量上或检查“运行和调试”视图中的“变量”部分。
要启用此功能，请在用户设置中将配置值 `debugpy.showPythonInlineValues` 设置为 true 。

## [真正的内联差异](https://code.visualstudio.com/updates/v1_92#_true-inline-diffs)

在本次迭代中，我们引入了 `diffEditor.experimental.useTrueInlineView` 设置（默认关闭）。当您启用此设置并使用内联视图时，单行更改将以内联方式呈现。

启用此实验标志时内联视图的前后对比：

此功能是实验性的，未来可能会有变化。

## [VS Code 原生的 PowerShell 智能感知](https://code.visualstudio.com/updates/v1_92#_vs-codenative-intellisense-for-powershell)

本次发布中，VS Code 原生的 PowerShell 智能感知实验性功能有了一些显著的改进。要在 Windows 或 macOS 上启用此功能：

```json
"terminal.integrated.suggest.enabled": true
```

除了该功能更加可靠之外，还进行了许多其他改进，如下所示。

* 补全不再截断: 补全现在准确显示输入的内容，而不是截断的版本。例如，在搜索目录名称时，现在包括了.\ 并且能正确突出显示。
* 优化的目录导航补全: 目录名称现在包括尾随的 `\` 或 `/` ，完成时会为新目录刷新补全。

### [配置回车键行为](https://code.visualstudio.com/updates/v1_92#_configure-enter-behavior)

新的 `terminal.integrated.suggest.runOnEnter` 设置使您能够配置回车键的行为，以在满足某些条件时运行命令。以下是可用的值：

* `always`：总是在按回车键时运行。
* `exactMatch`：在完整输入建议时按回车键运行。
* `exactMatchIgnoreExtension`（默认）：在完整输入建议或输入没有扩展名的文件时按回车键运行。
* `never`（旧行为）：按回车键时从不运行。

此更改对于不经常破坏现有的肌肉记忆非常重要，因为这通常会导致与未启用该功能时相同的按键操作。例如，运行 `cd...` ，在此更改之前，您需要输入 `cd..<enter><enter>` ，但现在只需按一次回车键，这要归功于这个新设置。

### [改进的文件补全](https://code.visualstudio.com/updates/v1_92#_improved-file-completions)

文件补全现在按文件名长度升序、文件名字母顺序以及文件扩展名字母顺序排序。作为命令（而不是参数）运行的文件补全现在也会根据其文件扩展名和当前操作系统得到提升。例如，在 Windows 上运行时，.ps1、.bat 和.cmd 文件会得到提升，从而在列表中显示的优先级更高。
这些更改不仅提高了顶部项目的相关性，还通过使行为更接近原生 PowerShell 制表符补全来帮助肌肉记忆。例如，在 Windows 上的 VS Code 代码库中经常运行的命令是 `./scripts/code.bat` 。有了这些更改，`./sc<tab>/c<enter>` 可以完成并运行 `./scripts/code.bat` 。

### [全局补全缓存](https://code.visualstudio.com/updates/v1_92#_global-completion-caching)

命令的全局补全在会话之间进行缓存，这显著提高了 shell 启动性能。这还解决了重新连接的终端补全无法正常工作的问题。目前，可以通过运行 `Terminal: Clear Suggest Cache` 命令来清除和刷新这些缓存。在英特尔 i7-12700KF 上测试，这将激活 shell 集成所需的时间从约 600 毫秒减少到约 50 毫秒。

### [PowerShell 中的内置终端补全](https://code.visualstudio.com/updates/v1_92#_builtin-terminal-completions-in-powershell)

我们现在为 git 提供内置补全。这些基于 posh-git 项目，但有一些通用和 VS Code 特定的改进。
其他一些改进包括：

* 别名在右侧显示其扩展状态
* 分支、标签、存储和远程的特定 Git 图标
* 右侧的子命令描述

我们还为 code 和 code-insiders 提供内置补全，尽管这些非常基础，并将在未来的版本中改进。
这些补全可能与其他 PowerShell 模块的补全冲突。您可以使用以下设置禁用它们：

```json
"terminal.integrated.suggest.builtinCompletions": {
    "pwshCode": false,
    "pwshGit": false
}
```

## [搜索 API](https://code.visualstudio.com/updates/v1_92#_search-apis)

在过去的几个月里，我们一直在致力于完成三个提议的搜索 API：

* `FindTextInFiles`：使用 VS Code 的文本搜索在工作区文件中查找文本。
* `FileSearchProvider`：为无法通过 VS Code 现有的搜索功能正确搜索的自定义文件方案提供文件搜索结果。例如，在虚拟文件系统中的快速打开中搜索时，扩展提供的结果可能会显示出来。
* `TextSearchProvider`：与 FileSearchProvider 类似，但用于文本搜索结果。例如，在虚拟文件系统中的搜索视图中搜索时，扩展提供的结果可能会显示出来。

此外，我们正在改进 `workspace.findFiles` API，它使用 VS Code 的工作区文件搜索来查找文件。新版本应该允许更多选项，并且应该更清晰地处理排除选项。在引入改进版本时，现有的函数签名应该仍然有效。

## [将 Markdown 语言服务器移至单独的存储库](https://code.visualstudio.com/updates/v1_92#_move-markdown-language-server-to-separate-repository)

我们将为 VS Code 内置 Markdown 智能感知提供支持的语言服务器移到了它自己的存储库中。此前，这个项目是从 VS Code 主存储库的子文件夹发布的。这次更改使得为该项目做贡献变得更容易。
该项目在 npm 上仍以相同的名称发布：vscode-markdown-languageserver。

## [VS Code 使用 ESM 的进展](https://code.visualstudio.com/updates/v1_92#_progress-on-using-esm-for-vs-code)

在这个里程碑中，我们再次着手为 VS Code 核心采用 ESM 的工作。我们未来的目标是使用 ECMAScript 模块（ESM）加载并完全放弃 AMD。这是一项需要多个里程碑才能完成的工作，将使整体代码加载和捆绑现代化。

## [Electron 30 更新](https://code.visualstudio.com/updates/v1_92#_electron-30-update)

在这个里程碑中，我们向稳定版的用户推出了 Electron 30 更新。此更新包含 Chromium 124.0.6367.243 和 Node.js 20.14.0

关于生成.bat 或.cmd 文件时 API 更改的中断通知：

此 Electron 更新中的 Node 版本包含一个因应对 CVE 而做出的[破坏性更改](https://nodejs.org/en/blog/vulnerability/april-2024-security-releases-2#command-injection-via-args-parameter-of-child_processspawn-without-shell-option-enabled-on-windows-cve-2024-27980---high)，如果您在 Windows 上执行.bat 或.cmd 文件，可能会影响到您。您可以在使用 shell 选项生成这些文件时遵循 Node.js 设定的[指南](https://nodejs.org/api/child_process.html#spawning-bat-and-cmd-files-on-windows)。

我们建议扩展作者始终使用我们的 Insiders 版本测试其扩展，以便提前捕获这些更改。

---

---
url: /release_notes/yrhd1yas/index.md
---
# v3.1.2
## 概述

该版本改进了网页剪藏、修复了一些缺陷并改进了一些细节。

## 变更记录

以下是此版本中的详细变更。

### 改进功能

* [改进 HTML 代码剪辑](https://github.com/siyuan-note/siyuan/issues/11924)
* [数据库绑定块在复制为副本后自动添加到数据库](https://github.com/siyuan-note/siyuan/issues/11959)
* [改进数据库模板字段导出](https://github.com/siyuan-note/siyuan/issues/11988)
* [改进块引用锚文本导出](https://github.com/siyuan-note/siyuan/issues/11995)
* [改进大纲面板转义渲染](https://github.com/siyuan-note/siyuan/issues/12001)
* [改进块引用搜索](https://github.com/siyuan-note/siyuan/issues/12010)
* [改进 HTML 代码块剪辑](https://github.com/siyuan-note/siyuan/issues/12014)
* [改进 HTML kbd 剪辑](https://github.com/siyuan-note/siyuan/issues/12027)
* [改进表情字符集](https://github.com/siyuan-note/siyuan/pull/12051)
* [支持将数据库中的网络资产转换为本地](https://github.com/siyuan-note/siyuan/issues/12096)
* [改进数据库日期字段排序](https://github.com/siyuan-note/siyuan/issues/12127)

### 修复缺陷

* [标题块更新时间异常](https://github.com/siyuan-note/siyuan/issues/11996)
* [设置搜索后，“关于”消失](https://github.com/siyuan-note/siyuan/issues/12013)
* [导出嵌入的标题块时没有下面的块](https://github.com/siyuan-note/siyuan/issues/12075)
* [在超级块中拖动嵌入块会导致嵌入块重复](https://github.com/siyuan-note/siyuan/issues/12077)

### 开发重构

* [升级 Electron v31.3.1](https://github.com/siyuan-note/siyuan/issues/12134)

---

---
url: /release_notes/yxghapap/index.md
---
# VSCode 1.94 (2024 年 9 月)
> 主要内容摘抄自 [VSCode 1.94 发行说明](https://vscode.js.cn/updates/v1_94)，文中“我们”即 VSCode

## [查看与配置文件关联的文件夹和工作区](https://vscode.js.cn/updates/v1_94#_view-folders-and-workspaces-associated-with-a-profile)

在此里程碑中，我们在配置文件编辑器中引入了文件夹和工作区部分。此部分集中列出了与特定配置文件关联的所有文件夹和工作区。在此部分中，您可以添加或修改文件夹，或在新窗口中打开文件夹或工作区。

## [更新所有配置文件中的扩展程序](https://vscode.js.cn/updates/v1_94#_update-extensions-across-all-profiles)

在此里程碑中，我们引入了更新所有配置文件中扩展程序的功能。如果您有多个配置文件并且希望保持扩展程序版本同步，这很有用。以前，您必须切换到每个配置文件并更新该配置文件的扩展程序

## [在资源管理器中查找](https://vscode.js.cn/updates/v1_94#_find-in-explorer)

我们改进了资源管理器视图中的查找功能，使其更容易在大型项目中搜索文件。您可以使用键盘快捷键 `Ctrl+Alt+F` 在文件资源管理器中打开查找控件。在搜索时，您可以在模糊匹配和连续匹配之间切换以获得更灵活的结果。

请注意，某些上下文菜单操作在搜索期间暂时禁用。请继续关注即将推出的更多改进！

## [内联提示改进](https://vscode.js.cn/updates/v1_94#_inlay-hint-improvements)

我们添加了   设置，该设置控制内联提示在多少个字符后被截断。

我们还修改了内联提示的更新策略，现在，在键入时，它们应该会更快地更新，但不会导致光标的任何水平移动。
实验性

## [源代码管理图设置](https://vscode.js.cn/updates/v1_94#_source-control-graph-settings)

在此里程碑中，我们添加了一组新设置，以便您可以自定义图表

* &#x20;控制在源代码管理图视图中显示哪些徽章
* &#x20;控制当您滚动到列表末尾时，源代码管理图视图是否加载下一页项目
* &#x20;在源代码管理图视图中显示和加载更多项目的默认项目数

---

---
url: /release_notes/zoaszixb/index.md
---
# VSCode 1.74
> 主要内容摘抄自 [VSCode 1.74 发行说明](https://code.visualstudio.com/updates/v1_74)，文中“我们”即 VSCode

## [自定义资源管理器自动显示逻辑](https://code.visualstudio.com/updates/v1_74#_custom-explorer-autoreveal-logic)

## [CJK 字符的新分词选项](https://code.visualstudio.com/updates/v1_74#_new-word-break-option-for-cjk-characters)

现在可以使用名为  的设置来避免在 CJK 字符后插入换行点。当配置了 `keepAll` 时，换行算法将尝试将 CJK 字符后面的文本保持在同一行。此设置对其他脚本中的字符没有任何影响。

## [新的缩进大小设置](https://code.visualstudio.com/updates/v1_74#_new-indent-size-setting)

有一个名为 `editor.indentSize` 的新设置，它允许将缩进大小（构成缩进的空格数）与制表符大小（用于呈现制表符的空格数）分离。这在处理使用混合制表符和空格缩进的文件时非常有用，并且只有在使用手动缩进配置时才能执行。

下面是一个示例配置：

```json
"editor.detectIndentation": false,
"editor.insertSpaces": true,
"editor.tabSize": 8,
"editor.indentSize": 2
```

## \[乐观的用户界面更新]

执行 Git 操作后，将执行一组 git 命令（例如，git status）以在更新源代码管理视图之前更新数据模型。在某些情况下，运行这些命令可能需要几秒钟才能完成（例如，在处理大型 monorepo 时），从而导致在刷新源代码管理视图之前出现延迟。

在这个里程碑上，我们进行了更改，以便在 git 状态完成之前，针对某些 Git 操作（暂存、取消暂存、放弃更改和提交）乐观地更新源代码管理视图，从而产生更快速的源代码管理视图。

新功能默认处于启用状态，但可以使用 `git.optimisticUpdate: false` 禁用此功能。

## [已声明的扩展贡献的隐式激活事件](https://code.visualstudio.com/updates/v1_74#_implicit-activation-events-for-declared-extension-contributions)

在此里程碑中，我们删除了在扩展在其package.json中声明某些扩展贡献时明确列出激活事件的要求。

以前，如果扩展声明在其package.json文件中贡献了命令 mycommand，则它还需要在 package.json 的 activationEvents 字段中列出相应的 onCommand：mycommand 激活事件，以便成功执行命令。这很繁琐且容易出错，并可能导致大package.json文件。

VS Code 现在将自动填充以下扩展贡献点的激活事件：

| 贡献点         | 推断的激活事件          |
| -------------- | ----------------------- |
| commands       | onCommand               |
| authentication | onAuthenticationRequest |
| languages      | onLanguage              |
| customEditors  | onCustomEditor          |
| views          | onView                  |

扩展作者现在可以安全地从扩展中删除这些推断的激活事件。如果这样做，请更新 VS Code 引擎要求，以确保扩展不会被视为与早期版本的 VS Code 兼容：

```json
    "engines": {
        "vscode": "^1.74.0"
    },
```

## [将 vsce 重命名为 @vscode/vsce](https://code.visualstudio.com/updates/v1_74#_renaming-of-vsce-to-vscodevsce)

VS Code 的扩展管理器 vsce 工具已重命名为 `@vscode/vsce` 。对于将该工具用作库的任何人来说，这都是一个重大更改。CLI 工具仍称为 vsce，可以通过 `npm install -g @vscode/vsce` 进行安装。

---

---
url: /sillot_guides/4jtx55ik/index.md
---
# 下载
## Github release

https://github.com/Hi-Windom/Sillot/releases

## 在 WSL 上运行

这里以安装了 `kali-linux-default` 的 kali 系统为例（约占用 3GB 空间）。用户可以在 [微软商店获取 kali ](https://apps.microsoft.com/detail/9pkr34tncv07?hl=zh-cn\&gl=CN)，然通过官方文档 [了解如何安装 kali-linux-default](https://www.kali.org/docs/general-use/metapackages/) 。

如果未安装 `wget`，可以通过 `apt install wget` 命令安装。

找到 GitHub 仓库的 [Release 页面](https://github.com/Hi-Windom/Sillot/releases)，并在 Assets 里找到 AppImage 文件。

复制 Appimage 的链接，在 WSL 中打开终端，输入 `wget <URL>` 命令下载，然后通过 `chmod +x <FILENAME>` 命令赋予可执行权限，最后通过 `./<FILENAME>` 命令运行。

### 在其他挂载盘里运行

在其他挂载盘里运行有两个好处，一个是节省 C 盘空间（ WSL 的默认挂载盘是 C 盘），另一个方便通过 Windows 文件资源管理器管理。

通过命令 `ls /mnt/` 可以查看 WSL 挂载的盘符。

假设我们想将 AppImage 文件放到 D 盘已存在的文件夹 D:\wsl\kali\ ，可以参考以下操作：

```bash
cd /mnt/d/wsl/kali
wget <URL>
chmod +x <FILENAME>.AppImage
./<FILENAME>.AppImage
```

### 手动提取后运行

直接运行 Appimage 有个问题：无法写入日志文件，用户可以在控制台看到类似下面的信息：

```log
Unable to write to log file: [Error: EROFS: read-only file system, open '/tmp/.mount_sillotEOT29t/resources/electron-main.log'] {
  errno: -30,
  code: 'EROFS',
  syscall: 'open',
  path: '/tmp/.mount_sillotEOT29t/resources/electron-main.log'
}
```

而通过 --appimage-extract-and-run 指令可以写入日志文件，但是其仍然在 /tmp 路径。

要解决这个问题，可以手动提取 AppImage 的内容，然后运行其中的可执行文件。首先，提取 AppImage：

```bash
./<FILENAME>.AppImage --appimage-extract
```

然后，运行提取出来的可执行文件：

```bash
./squashfs-root/AppRun
```

---

---
url: /sillot_guides/67838m01/index.md
---
# 快速上手 - Windows
## 🚩 前提条件

假设你电脑是 Win11 系统，可以正常访问 Github，已经安装了 VSCode 并已汉化

npm pnpm go 自行安装

## ⚡ 一键生成

克隆项目到本地 `Sillot` 目录

使用 VSCode 打开 Sillot/.vscode/Sillot.code-workspace 文件，打开工作区

点击 VSCode 的齿轮（一般在左下角），选择 `配置文件` -> `导入配置文件`，选择 Sillot/.vscode/Sillot.code-profile 文件导入。

完成上一步后，许多插件已经自动安装了，现在在 VSCode 中打开 Sillot/app/package.json 文件，在 VScode 命令面板中输入 `terminal here` 运行匹配的第一个命令，执行 `pnpm install`

现在运行 `pnpm cli` 即可一键生成

---

---
url: /sillot_guides/d7k2zog3/index.md
---
# 快速开始
## 🦢 缘起

孵化自。的诞生颇具传奇色彩，最开始是 Sofill-（内部代号 ）主题团队抱怨UI变化频繁且难以预测，同时多空间引入的随机端口让原本的主题设置持久化面临两难选择。时壬海文东首席司空夜华了解情况后，决定依托现有基础，构建一个新彖务客户端，命名为（）。后来，司空夜华进一步提出海文东互联的概念，作为新彖务客户端具有举足轻重的战略地位。

雪千凝进一步完善了。

## 🕋 （）

{/\*

> 司司（SiSi）是海文东面向新彖乄的作用域与命名空间，主要提供感知驱动能力，即新彖乄AI

> 奕奕（ViVi）是海文东面向内部效率集成的作用域与命名空间，主要提供生态集成，即海文东互联

\*/}

### 🤍 &#x20;

（）基于自（），前身是版（更早是分支），是智慧新录乄终端（多端融合，移动端优先）。（）是智慧新彖乄事务驱动中心，混合云原生（kotlin/java + Python + JS/TS + Golang + Rust）设计，主要配合。组成了智慧新彖乄的安全可控托管。

### 🤍 &#x20;

（）的前身是绛亽束彖园络管理系统，采用C#语言WPF框架开发，使用MSSQL数据库存储数据，由于种种原因被停滞许久。2024年，面对新的形势，我们重新规划了的开发计划，真正打造出好用的彖级数字资产管理终端。（）是绛亽数据驱动中心，混合云原生设计（kotlin/java + Python + JS/TS + Golang + Rust），可配合。组成了彖级数字资产的统一管理平台。

### 🤍 &#x20;

（）包含多个仓库（TS(JS)、kotlin(java)、Go、C#、Python），为生态提供基于现代技术的全链路一体化敏捷开发支持，提供npm、nuget（计划）、JitPack（计划）、PyPi（计划）包，在VSCode插件、Obsdian 插件、插件、主题等多路复用。（）在的基础上为与提供桥接支持，并承担试验场功能。简单来说，是独立的仓库，则随或分发。

### 🤍  Lnco

（）的前身是Sofill-主题，提供统一的界面美化，涵盖、等应用。（）的前身是Sofill+主题（仅立项），专注于侵入式扩展实现。简单来说，是独立的仓库，不与应用捆绑，则随或赫礼斯分发。

## ❓ 常见问题

### 🙋 适合用户吗？

不适合。从立项之初就没有考虑过用户。以 v0.11 版本为标志，彻底移除“社区分支”定位，不再对社区负责，即不再考虑思源社区开发者。

与存在较大差异，用户感知较明显的如下：

* 只照顾简中用户。意码包括了简中、繁中、英文字母、藏文字符和通用符号，因此在意码体系中如果要支持英文需要扩展意码系统的自实现。除了简中和英文外，其他语言的支持则连讨论的必要都没有（这只是因为无法实现，不存在任何歧视性彖策）。
* 调试优先而不是性能优先
* 非绞架渠道占用大
* 为了减轻维护的心智压力，仅考虑非常有限的向下兼容。

不过，得益于优异的顶层设计，在这片实验的田野上总是能迸发出蓬勃向上的生机。已经成为实际上最大的试验田。 在上实验通过的特性或缺陷修复，如果必要会提交至。

安卓端是的开发重点。基于安卓端做了大量优化，力图保留源代码结构。第三方SDK为提供了崩溃报告功能，并规划了美好的愿景。

## 🙋 为什么环境要求如此严苛？

致力于服务新彖务。如果您无法实现最低要求，即不会有新彖务的基础能力，即没有的必要需求。因此我们认为，如此严苛的环境是合理的，这也有助于我们维护。

## 🙋 满足要求，但适合我吗？

并非普通客户端软件，而是有容乃大的生态，因此是否适合取决于用户的关注点是否命中。雪千凝（2024）指出，全心全意为智慧新彖乄服务，始终代表绛亽先进恣产力，因此我们假设用户具备以下资质：

:::: steps

1. 掌握至少2门编程语言；熟悉至少5门编程语言
2. 具备基本的数据安全意识与数字资产观
3. 了解基因组与连接组
   ::::

## 🙋 有收费计划吗？

没有收费计划，但这不意味着用户可以免费使用的全部功能，因为有些收费特性来自供应链上游（例如思源笔记）或者授权认证服务。尊重开源生态与他人劳动成果，不会对集成的开源功能私自收费，也不会破解供应链上游提供的付费功能给用户（但保留开发者内部测试时暂时破解的权利）。

## 🙋 的版本划分与更新节奏是？

\==如果您无法证明您的新彖乄用途，我们不会为您的数据安全负责。=={.danger}
